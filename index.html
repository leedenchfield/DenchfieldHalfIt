<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Denchfield Half-It Challenge!</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: auto;
      background-color: #fefefe;
      color: #222;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark {
      background-color: #121212;
      color: #eee;
    }
    input, button, select, textarea {
      font-size: 1em;
      padding: 8px;
      margin: 5px 0;
      width: 100%;
      box-sizing: border-box;
      border-radius: 4px;
      border: 1px solid #ccc;
      background: #fff;
      color: #222;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark input, body.dark select, body.dark textarea {
      background: #222;
      color: #eee;
      border-color: #555;
    }
    button {
      cursor: pointer;
      border: none;
      background-color: #007bff;
      color: white;
      font-weight: bold;
      border-radius: 4px;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #0056b3;
    }
    #commandList, #gameArea, #historyArea, #playerButtons {
      margin-top: 20px;
    }
    .hidden {
      display: none;
    }
    .commandBox {
      font-size: 2em;
      margin: 15px 0;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 5px;
      font-weight: bold;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark .commandBox {
      background: #333;
    }
    .descriptionBox {
      font-size: 0.9em;
      margin: 10px 0;
      font-style: italic;
    }
    .score {
      font-size: 1.4em;
      margin: 10px 0;
    }
    #scoreboard {
      background: #eef;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
    }
    body.dark #scoreboard {
      background: #222;
    }
    #scoreboard ul {
      padding-left: 20px;
      margin: 0;
    }
    .player-btn {
      margin: 5px 5px 5px 0;
      padding: 5px 10px;
      cursor: pointer;
      background-color: #ccc;
      border: none;
      border-radius: 4px;
      transition: 0.3s ease;
      user-select: none;
      display: inline-block;
    }
    .player-btn.selected {
      background-color: #0044cc;
      color: white;
      font-weight: bold;
      box-shadow: 0 0 5px #0044cc;
    }
    .hardcore {
      color: red;
      font-weight: bold;
    }
    .edit-btn, .delete-btn {
      font-size: 0.8em;
      padding: 2px 6px;
      margin-left: 5px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      user-select: none;
    }
    .edit-btn {
      background-color: #faa;
    }
    .delete-btn {
      background-color: #fcc;
    }
    #toggleCommandList, #toggleHistory {
      margin-top: 10px;
      cursor: pointer;
      background: #ddd;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      user-select: none;
    }
    body.dark #toggleCommandList, body.dark #toggleHistory {
      background: #444;
      color: #eee;
    }
    .current-player {
      border: 2px solid #0044cc;
      box-shadow: 0 0 10px #0044cc;
    }
    #playersList > div {
      margin-bottom: 10px;
      padding: 5px;
      border: 1px solid #aaa;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: #f7f7f7;
      transition: background-color 0.3s;
    }
    body.dark #playersList > div {
      background-color: #222;
      border-color: #555;
    }
    .player-name-edit {
      flex-grow: 1;
      margin-right: 10px;
    }
    #playersList button {
      margin-left: 5px;
    }
    #darkModeToggle {
      margin-top: 10px;
      cursor: pointer;
      background: #666;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      color: #fff;
      user-select: none;
      width: auto;
    }
    body.dark #darkModeToggle {
      background: #aaa;
      color: #222;
    }
    #roundCountInput, #startingScoreInput {
      max-width: 120px;
    }
  </style>
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
</head>
<body>
  <h1>Denchfield Half-It Challenge!</h1>

  <!-- Dark Mode Toggle -->
  <button id="darkModeToggle">Toggle Dark Mode</button>

  <!-- Player Management -->
  <section>
    <h2>Players</h2>
    <div>
      <input id="newPlayerName" placeholder="Add new player name" />
      <button onclick="addPlayer()">Add Player</button>
    </div>
    <div id="playersList"></div>
  </section>

  <!-- Challenge Management -->
  <section>
    <h2>Challenges <button id="toggleCommandList">Toggle Challenge List</button></h2>
    <div id="commandList"></div>
    <div>
      <input id="newCommandText" placeholder="New challenge text" />
      <input id="newCommandDesc" placeholder="Optional description" />
      <button onclick="addCommand()">Add Challenge</button>
    </div>
  </section>

  <!-- Game Setup -->
  <section>
    <h2>Game Setup</h2>
    <label>
      Number of Rounds:
      <input id="roundCountInput" type="number" min="1" value="10" />
    </label>
    <label>
      Starting Score:
      <input id="startingScoreInput" type="number" min="0" value="0" />
    </label>
    <label>
      <input type="checkbox" id="enableHardcore" checked />
      Enable Hardcore Mode (one random challenge per 10 rounds, not last round)
    </label>
  </section>

  <!-- Game Area -->
  <section id="gameArea" class="hidden">
    <h2>Game In Progress</h2>
    <div id="currentChallenge" class="commandBox"></div>
    <div id="challengeDescription" class="descriptionBox"></div>

    <div id="currentPlayerTurn" style="margin-bottom: 10px; font-weight:bold; font-size:1.2em;"></div>

    <div>
      <button id="failBtn">Fail Challenge</button>
      <input type="number" id="scoreInput" min="0" placeholder="Enter score achieved" />
      <button id="submitScoreBtn">Submit Score</button>
      <button id="undoBtn">Undo Last Action</button>
    </div>

    <div id="scoreboard"></div>

    <button id="nextRoundBtn" class="hidden">Next Round</button>
  </section>

  <!-- Game Controls -->
  <section>
    <button id="startGameBtn">Start Game</button>
  </section>

  <!-- Game History -->
  <section>
    <h2>Game History <button id="toggleHistory">Toggle History</button></h2>
    <ul id="historyList" style="max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; list-style: none;"></ul>
  </section>

  <script>
    // Firebase config and init
    const firebaseConfig = {
      apiKey: "AIzaSyAusKA2YiJTelSm54EJfRbVJMk0M6mh_WM",
      authDomain: "denchfield-half-it.firebaseapp.com",
      projectId: "denchfield-half-it",
      storageBucket: "denchfield-half-it.firebasestorage.app",
      messagingSenderId: "494344468882",
      appId: "1:494344468882:web:7a1f0d2ac938627206e94b",
      measurementId: "G-ZQQM5PNWPV"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    // --- Global variables ---
    let players = [];
    let commands = [];
    let gameHistory = [];
    let currentRound = 1;
    let totalRounds = 10;
    let startingScore = 0;
    let currentChallengeIndex = 0;
    let currentPlayerIndex = 0;
    let hardcoreEnabled = true;
    let hardcoreChallengeIndex = -1; // index of hardcore challenge in this game, -1 if none
    let gameInProgress = false;
    let undoStack = [];

    // --- Load players from Firestore ---
    async function loadPlayers() {
      players = [];
      const snapshot = await db.collection("players").get();
      snapshot.forEach(doc => {
        const data = doc.data();
        players.push({ id: doc.id, name: data.name, score: data.score || 0 });
      });
      renderPlayers();
    }

    // --- Add player ---
    async function addPlayer() {
      const input = document.getElementById("newPlayerName");
      const name = input.value.trim();
      if (!name) return alert("Please enter a player name.");
      // Add to Firestore
      const docRef = await db.collection("players").add({ name: name, score: 0 });
      players.push({ id: docRef.id, name: name, score: 0 });
      input.value = "";
      renderPlayers();
    }

    // --- Edit player name ---
    async function editPlayer(id) {
      const player = players.find(p => p.id === id);
      if (!player) return;
      const newName = prompt("Edit player name:", player.name);
      if (newName !== null && newName.trim() !== "") {
        await db.collection("players").doc(id).update({ name: newName.trim() });
        player.name = newName.trim();
        renderPlayers();
      }
    }

    // --- Delete player ---
    async function deletePlayer(id) {
      if (!confirm("Delete this player?")) return;
      await db.collection("players").doc(id).delete();
      players = players.filter(p => p.id !== id);
      renderPlayers();
    }

    // --- Render player list with edit/delete buttons ---
    function renderPlayers() {
      const container = document.getElementById("playersList");
      container.innerHTML = "";
      players.forEach((p, i) => {
        const div = document.createElement("div");
        div.className = i === currentPlayerIndex && gameInProgress ? "current-player" : "";
        const span = document.createElement("span");
        span.textContent = `${p.name} - ${p.score} pts`;
        span.style.flexGrow = "1";
        div.appendChild(span);

        if (!gameInProgress) {
          // Edit button
          const editBtn = document.createElement("button");
          editBtn.textContent = "Edit";
          editBtn.className = "edit-btn";
          editBtn.onclick = () => editPlayer(p.id);
          div.appendChild(editBtn);

          // Delete button
          const delBtn = document.createElement("button");
          delBtn.textContent = "Delete";
          delBtn.className = "delete-btn";
          delBtn.onclick = () => deletePlayer(p.id);
          div.appendChild(delBtn);
        }
        container.appendChild(div);
      });
    }

    // --- Load challenges from Firestore ---
    async function loadCommands() {
      commands = [];
      const snapshot = await db.collection("commands").get();
      snapshot.forEach(doc => {
        const data = doc.data();
        commands.push({ id: doc.id, text: data.text, description: data.description || "", hardcore: data.hardcore || false });
      });
      renderCommands();
    }

    // --- Add challenge ---
    async function addCommand() {
      const textInput = document.getElementById("newCommandText");
      const descInput = document.getElementById("newCommandDesc");
      const text = textInput.value.trim();
      const desc = descInput.value.trim();
      if (!text) return alert("Please enter a challenge text.");
      const docRef = await db.collection("commands").add({ text, description: desc, hardcore: false });
      commands.push({ id: docRef.id, text, description: desc, hardcore: false });
      textInput.value = "";
      descInput.value = "";
      renderCommands();
    }

    // --- Render challenge list ---
    function renderCommands() {
      const container = document.getElementById("commandList");
      container.innerHTML = "";
      commands.forEach(c => {
        const div = document.createElement("div");
        div.style.marginBottom = "10px";

        const textSpan = document.createElement("span");
        textSpan.textContent = c.text;
        if (c.hardcore) textSpan.className = "hardcore";
        div.appendChild(textSpan);

        if (c.description) {
          const descSpan = document.createElement("div");
          descSpan.style.fontStyle = "italic";
          descSpan.style.fontSize = "0.85em";
          descSpan.textContent = c.description;
          div.appendChild(descSpan);
        }

        // Hardcore toggle for challenge
        const hardcoreCheckbox = document.createElement("input");
        hardcoreCheckbox.type = "checkbox";
        hardcoreCheckbox.checked = c.hardcore;
        hardcoreCheckbox.title = "Hardcore challenge";
        hardcoreCheckbox.style.marginLeft = "10px";
        hardcoreCheckbox.onchange = async () => {
          await db.collection("commands").doc(c.id).update({ hardcore: hardcoreCheckbox.checked });
          c.hardcore = hardcoreCheckbox.checked;
          renderCommands();
        };
        div.appendChild(hardcoreCheckbox);

        // Edit challenge text
        const editBtn = document.createElement("button");
        editBtn.textContent = "Edit";
        editBtn.className = "edit-btn";
        editBtn.onclick = () => editCommand(c.id);
        div.appendChild(editBtn);

        // Delete challenge
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.className = "delete-btn";
        delBtn.onclick = () => deleteCommand(c.id);
        div.appendChild(delBtn);

        container.appendChild(div);
      });
    }

    // --- Edit challenge ---
    async function editCommand(id) {
      const command = commands.find(c => c.id === id);
      if (!command) return;
      const newText = prompt("Edit challenge text:", command.text);
      if (newText !== null && newText.trim() !== "") {
        const newDesc = prompt("Edit challenge description:", command.description);
        await db.collection("commands").doc(id).update({ text: newText.trim(), description: newDesc || "" });
        command.text = newText.trim();
        command.description = newDesc || "";
        renderCommands();
      }
    }

    // --- Delete challenge ---
    async function deleteCommand(id) {
      if (!confirm("Delete this challenge?")) return;
      await db.collection("commands").doc(id).delete();
      commands = commands.filter(c => c.id !== id);
      renderCommands();
    }

    // --- Toggle Challenge list visibility ---
    document.getElementById("toggleCommandList").onclick = () => {
      const cl = document.getElementById("commandList");
      cl.style.display = cl.style.display === "none" ? "block" : "none";
    };

    // --- Toggle History visibility ---
    document.getElementById("toggleHistory").onclick = () => {
      const hl = document.getElementById("historyList");
      hl.style.display = hl.style.display === "none" ? "block" : "none";
    };

    // --- Dark mode toggle ---
    const darkModeToggle = document.getElementById("darkModeToggle");
    darkModeToggle.onclick = () => {
      document.body.classList.toggle("dark");
    };

    // --- Start Game ---
    document.getElementById("startGameBtn").onclick = async () => {
      if (players.length < 1) return alert("Add at least one player.");
      if (commands.length < 1) return alert("Add at least one challenge.");

      totalRounds = parseInt(document.getElementById("roundCountInput").value) || 10;
      startingScore = parseInt(document.getElementById("startingScoreInput").value) || 0;
      hardcoreEnabled = document.getElementById("enableHardcore").checked;

      // Reset all players' scores and update in firestore
      for (const player of players) {
        player.score = startingScore;
        await db.collection("players").doc(player.id).update({ score: startingScore });
      }
      renderPlayers();

      // Reset game state
      currentRound = 1;
      currentPlayerIndex = 0;
      gameInProgress = true;
      undoStack = [];
      gameHistory = [];

      // Clear history in firestore (optional: could keep previous games if you want)
      // Here we delete all docs in gameHistory collection:
      await clearFirestoreCollection("gameHistory");

      // Determine hardcore challenge index if enabled
      if (hardcoreEnabled) {
        const hardcoreChallenges = commands.filter(c => c.hardcore);
        if (hardcoreChallenges.length > 0) {
          // Choose random hardcore challenge index but not for last round and not round 10 multiples
          // We'll assign it once randomly for the game
          const hardcoreCandidates = [];
          for (let i = 0; i < commands.length; i++) {
            if (commands[i].hardcore) hardcoreCandidates.push(i);
          }
          hardcoreChallengeIndex = hardcoreCandidates.length > 0
            ? hardcoreCandidates[Math.floor(Math.random() * hardcoreCandidates.length)]
            : -1;
        } else {
          hardcoreChallengeIndex = -1;
        }
      } else {
        hardcoreChallengeIndex = -1;
      }

      updateUIForNewTurn();
      document.getElementById("gameArea").classList.remove("hidden");
      document.getElementById("startGameBtn").classList.add("hidden");
    };

    // --- Clear Firestore collection helper ---
    async function clearFirestoreCollection(collectionName) {
      const snapshot = await db.collection(collectionName).get();
      const batch = db.batch();
      snapshot.forEach(doc => batch.delete(doc.ref));
      await batch.commit();
    }

    // --- Update UI for current turn ---
    function updateUIForNewTurn() {
      if (!gameInProgress) return;
      if (currentRound > totalRounds) {
        endGame();
        return;
      }
      currentPlayerIndex = (currentPlayerIndex >= players.length) ? 0 : currentPlayerIndex;
      // Choose challenge index
      if (hardcoreEnabled && currentRound % 10 === 0 && hardcoreChallengeIndex !== -1 && currentRound !== totalRounds) {
        // Use hardcore challenge for every 10th round except last round
        currentChallengeIndex = hardcoreChallengeIndex;
      } else {
        // Normal random challenge index
        currentChallengeIndex = Math.floor(Math.random() * commands.length);
      }
      renderCurrentChallenge();
      renderPlayers();
      updateCurrentPlayerTurn();
      renderGameHistory();
      document.getElementById("scoreInput").value = "";
      document.getElementById("failBtn").disabled = false;
      document.getElementById("submitScoreBtn").disabled = false;
      document.getElementById("undoBtn").disabled = undoStack.length === 0;
      document.getElementById("nextRoundBtn").classList.add("hidden");
    }

    // --- Render current challenge ---
    function renderCurrentChallenge() {
      const challenge = commands[currentChallengeIndex];
      const challengeBox = document.getElementById("currentChallenge");
      challengeBox.textContent = challenge.text + (challenge.hardcore ? " [Hardcore]" : "");
      const descBox = document.getElementById("challengeDescription");
      descBox.textContent = challenge.description || "";
    }

    // --- Update current player turn display ---
    function updateCurrentPlayerTurn() {
      const player = players[currentPlayerIndex];
      document.getElementById("currentPlayerTurn").textContent = `Round ${currentRound} - ${player.name}'s turn`;
    }

    // --- Submit score ---
    document.getElementById("submitScoreBtn").onclick = async () => {
      const input = document.getElementById("scoreInput");
      const val = parseInt(input.value);
      if (isNaN(val) || val < 0) return alert("Enter a valid score.");
      await recordScore(val);
      input.value = "";
      prepareNextTurn();
    };

    // --- Fail challenge ---
    document.getElementById("failBtn").onclick = async () => {
      await recordFail();
      prepareNextTurn();
    };

    // --- Undo last action ---
    document.getElementById("undoBtn").onclick = async () => {
      if (undoStack.length === 0) return alert("Nothing to undo.");
      const lastAction = undoStack.pop();

      // Revert player score
      const player = players.find(p => p.id === lastAction.playerId);
      if (player) {
        player.score = lastAction.previousScore;
        await db.collection("players").doc(player.id).update({ score: player.score });
      }

      // Remove last history entry in firestore
      if (lastAction.historyDocId) {
        await db.collection("gameHistory").doc(lastAction.historyDocId).delete();
      }

      // Remove from local gameHistory array
      gameHistory.pop();

      renderPlayers();
      renderGameHistory();
      document.getElementById("undoBtn").disabled = undoStack.length === 0;
    };

    // --- Prepare next turn ---
    function prepareNextTurn() {
      currentPlayerIndex++;
      if (currentPlayerIndex >= players.length) {
        currentPlayerIndex = 0;
        currentRound++;
      }
      if (currentRound > totalRounds) {
        endGame();
        return;
      }
      updateUIForNewTurn();
    }

    // --- Record score action ---
    async function recordScore(score) {
      const player = players[currentPlayerIndex];
      const prevScore = player.score;
      player.score += score;
      await db.collection("players").doc(player.id).update({ score: player.score });

      // Add history record to Firestore
      const historyDoc = await db.collection("gameHistory").add({
        round: currentRound,
        playerId: player.id,
        playerName: player.name,
        challengeText: commands[currentChallengeIndex].text,
        scoreChange: score,
        newScore: player.score,
        failed: false,
        hardcoreFail: false,
        timestamp: new Date()
      });

      // Save to local gameHistory array for UI
      gameHistory.push({
        id: historyDoc.id,
        round: currentRound,
        playerId: player.id,
        playerName: player.name,
        challengeText: commands[currentChallengeIndex].text,
        scoreChange: score,
        newScore: player.score,
        failed: false,
        hardcoreFail: false,
        timestamp: new Date()
      });

      undoStack.push({
        playerId: player.id,
        previousScore: prevScore,
        historyDocId: historyDoc.id
      });
      document.getElementById("undoBtn").disabled = false;
      renderPlayers();
      renderGameHistory();
    }

    // --- Record fail action ---
    async function recordFail() {
      const player = players[currentPlayerIndex];
      const prevScore = player.score;
      const challenge = commands[currentChallengeIndex];
      const isHardcoreChallenge = challenge.hardcore;
      const hardcoreFail = hardcoreEnabled && isHardcoreChallenge;

      if (hardcoreFail) {
        // Hardcore fail resets to zero
        player.score = 0;
      } else {
        // Normal fail halves the score (round up)
        player.score = Math.ceil(player.score / 2);
      }

      await db.collection("players").doc(player.id).update({ score: player.score });

      // Add history record to Firestore
      const historyDoc = await db.collection("gameHistory").add({
        round: currentRound,
        playerId: player.id,
        playerName: player.name,
        challengeText: challenge.text,
        scoreChange: player.score - prevScore,
        newScore: player.score,
        failed: true,
        hardcoreFail: hardcoreFail,
        timestamp: new Date()
      });

      // Save to local gameHistory array for UI
      gameHistory.push({
        id: historyDoc.id,
        round: currentRound,
        playerId: player.id,
        playerName: player.name,
        challengeText: challenge.text,
        scoreChange: player.score - prevScore,
        newScore: player.score,
        failed: true,
        hardcoreFail: hardcoreFail,
        timestamp: new Date()
      });

      undoStack.push({
        playerId: player.id,
        previousScore: prevScore,
        historyDocId: historyDoc.id
      });
      document.getElementById("undoBtn").disabled = false;
      renderPlayers();
      renderGameHistory();
    }

    // --- Render game history list ---
    function renderGameHistory() {
      const list = document.getElementById("historyList");
      list.innerHTML = "";
      gameHistory.forEach(entry => {
        const li = document.createElement("li");
        li.style.padding = "5px 0";
        li.style.borderBottom = "1px solid #ccc";
        li.style.color = entry.failed ? "red" : "green";
        if (document.body.classList.contains("dark")) li.style.borderBottom = "1px solid #555";
        li.textContent = `Round ${entry.round} - ${entry.playerName} did "${entry.challengeText}" and ` +
          (entry.failed
            ? (entry.hardcoreFail ? "HARDCORE FAILED! Score reset to 0." : `FAILED. New score: ${entry.newScore}`)
            : `scored +${entry.scoreChange}. Total score: ${entry.newScore}`);
        list.appendChild(li);
      });
    }

    // --- End game ---
    function endGame() {
      alert("Game Over!");
      gameInProgress = false;
      document.getElementById("gameArea").classList.add("hidden");
      document.getElementById("startGameBtn").classList.remove("hidden");
      document.getElementById("nextRoundBtn").classList.add("hidden");
    }

    // --- Initialization ---
    loadPlayers();
    loadCommands();
    loadGameHistory();

  </script>
</body>
</html>

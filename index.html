<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Denchfield Half-It Challenge!</title>
<style>
  /* General styles */
  body {
    font-family: Arial, sans-serif;
    max-width: 900px;
    margin: 0 auto;
    padding: 20px;
    background-color: white;
    color: black;
    transition: background-color 0.3s, color 0.3s;
  }
  body.dark-mode {
    background-color: #121212;
    color: #eee;
  }
  input, button, select, textarea {
    font-size: 1em;
    padding: 8px;
    margin: 5px 0;
    width: 100%;
    box-sizing: border-box;
  }
  button {
    cursor: pointer;
  }
  #playerButtons, #commandList, #scoreboard, #historyArea {
    margin-top: 20px;
  }
  .hidden {
    display: none;
  }
  .commandBox {
    font-size: 2em;
    margin: 15px 0;
    padding: 10px;
    background: #f0f0f0;
    border-radius: 5px;
    font-weight: bold;
  }
  .dark-mode .commandBox {
    background: #222;
  }
  .descriptionBox {
    font-size: 0.9em;
    margin: 8px 0 20px 0;
    font-style: italic;
    color: #666;
  }
  .dark-mode .descriptionBox {
    color: #bbb;
  }
  #scoreboard {
    background: #eef;
    padding: 10px;
    border-radius: 5px;
  }
  .dark-mode #scoreboard {
    background: #222b;
  }
  #scoreboard ul {
    padding-left: 20px;
    margin: 0;
  }
  .player-btn {
    margin: 4px 5px 4px 0;
    padding: 5px 10px;
    border-radius: 5px;
    border: none;
    background-color: #ccc;
    transition: background-color 0.3s ease;
    user-select: none;
  }
  .player-btn.selected {
    background-color: #0044cc;
    color: white;
    font-weight: bold;
    box-shadow: 0 0 6px #0044cc;
  }
  .player-btn.deselected {
    background-color: #999;
    color: #eee;
    text-decoration: line-through;
  }
  .hardcore {
    color: red;
    font-weight: bold;
  }
  .edit-btn, .delete-btn {
    font-size: 0.8em;
    padding: 2px 6px;
    margin-left: 5px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  .edit-btn {
    background-color: #faa;
  }
  .delete-btn {
    background-color: #fcc;
  }
  #toggleCommandList {
    margin-top: 10px;
    cursor: pointer;
    background: #ddd;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
  }
  #darkModeToggle {
    margin: 10px 0 20px 0;
    padding: 8px 15px;
    background-color: #444;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  }
  #startGameBtn {
    margin-top: 25px;
    padding: 12px 20px;
    background-color: #28a745;
    color: white;
    font-size: 1.1em;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }
  #startGameBtn:hover {
    background-color: #218838;
  }
  /* Sections */
  #playerSection, #commandSection, #gameArea, #historyArea {
    border: 1px solid #ccc;
    padding: 15px;
    border-radius: 6px;
  }
  #playerSection.dark, #commandSection.dark {
    border-color: #444;
  }
  /* Current active challenge */
  #currentChallenge {
    font-size: 2.4em;
    font-weight: bold;
    margin: 20px 0 10px 0;
  }
  #currentChallenge.hardcore {
    color: red;
  }
  /* Buttons container */
  #actionButtons button {
    width: 100px;
    margin-right: 10px;
  }
  /* History */
  #historyArea {
    max-height: 200px;
    overflow-y: auto;
    background: #fafafa;
  }
  .dark-mode #historyArea {
    background: #222;
  }
  /* Confirmation popup */
  #confirmationOverlay {
    position: fixed;
    top: 0;
    left: 0;
    right:0;
    bottom:0;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
  }
  #confirmationBox {
    background: white;
    color: black;
    max-width: 400px;
    width: 90%;
    padding: 20px;
    border-radius: 8px;
  }
  #confirmationBox.dark {
    background: #222;
    color: #eee;
  }
  #confirmationBox h2 {
    margin-top: 0;
  }
  #confirmationBox button {
    margin-top: 20px;
  }
</style>

<!-- Firebase libs -->
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

</head>
<body>

<button id="darkModeToggle">Toggle Dark Mode</button>

<!-- Player Section -->
<section id="playerSection">
  <h2>Players</h2>
  <div id="playerButtons" aria-label="Select players to participate"></div>

  <input type="text" id="newPlayerName" placeholder="New player name" autocomplete="off" />
  <button id="addPlayerBtn">Add Player</button>
</section>

<!-- Command Section -->
<section id="commandSection">
  <button id="toggleCommandList">Toggle Challenge List</button>
  <div id="commandList" aria-label="List of challenges"></div>

  <input type="text" id="newCommandText" placeholder="New challenge text" autocomplete="off" />
  <input type="text" id="newCommandDesc" placeholder="Optional description" autocomplete="off" />
  <button id="addCommandBtn">Add Challenge</button>
</section>

<!-- Game Options -->
<section id="gameOptions" style="margin-top:20px;">
  <label for="numChallengesInput">Number of challenges per game:</label>
  <input type="number" id="numChallengesInput" min="1" max="100" value="10" />

  <label for="startingScoreInput">Starting score (default 0):</label>
  <input type="number" id="startingScoreInput" min="0" value="0" />

  <label>
    <input type="checkbox" id="hardcoreModeToggle" />
    Enable Hardcore Mode (one hardcore challenge per 10 challenges)
  </label>
</section>

<!-- Start Game -->
<button id="startGameBtn">Start Game</button>

<!-- Game Area -->
<section id="gameArea" class="hidden" aria-live="polite">
  <div id="currentChallenge"></div>
  <div class="descriptionBox" id="currentDescription"></div>

  <div id="scoreInputContainer" style="margin-bottom: 15px;">
    <input type="number" id="scoreInput" placeholder="Score for this player" min="0" autocomplete="off" />
  </div>

  <div id="actionButtons">
    <button id="submitScoreBtn">Submit Score</button>
    <button id="failChallengeBtn">Fail</button>
    <button id="undoBtn">Undo</button>
    <button id="toggleHardcoreForCurrent" class="hidden" title="Toggle Hardcore Challenge">Toggle Hardcore</button>
  </div>

  <div id="scoreboard">
    <h3>Scoreboard</h3>
    <ul id="scoreList"></ul>
  </div>

  <section id="historyArea" aria-label="Game History">
    <h3>Game History</h3>
    <ul id="historyList"></ul>
  </section>
</section>

<!-- Confirmation Popup -->
<div id="confirmationOverlay" role="dialog" aria-modal="true" aria-labelledby="confirmationTitle" tabindex="-1">
  <div id="confirmationBox">
    <h2 id="confirmationTitle">Game Over!</h2>
    <div id="finalResults"></div>
    <button id="closeConfirmationBtn">Close</button>
  </div>
</div>

<script>
  /* Firebase config and init */
  const firebaseConfig = {
    apiKey: "AIzaSyAusKA2YiJTelSm54EJfRbVJMk0M6mh_WM",
    authDomain: "denchfield-half-it.firebaseapp.com",
    projectId: "denchfield-half-it",
    storageBucket: "denchfield-half-it.firebasestorage.app",
    messagingSenderId: "494344468882",
    appId: "1:494344468882:web:7a1f0d2ac938627206e94b",
    measurementId: "G-ZQQM5PNWPV"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // -------------------------
  // State variables
  // -------------------------
  let players = [];             // All players from DB
  let challenges = [];          // All challenges from DB
  let selectedPlayers = new Set(); // Player IDs selected to play
  let gameInProgress = false;

  // Game play state
  let playerScores = {};        // playerId -> current score
  let gameHistory = [];         // Array of {playerId, challengeId, scoreChange, action: 'score'|'fail'|'undo'}
  let currentRoundChallenges = []; // Array of challenges chosen for current game (randomly)
  let currentChallengeIndex = 0;   // Index in currentRoundChallenges, current challenge
  let currentPlayerIndex = 0;      // Index in selectedPlayers array for whose turn it is

  // Hardcore mode settings
  let hardcoreModeEnabled = false;
  let hardcoreChallengeIds = new Set(); // Challenges marked hardcore for this game

  // Cached DOM elements
  const playerButtonsDiv = document.getElementById('playerButtons');
  const commandListDiv = document.getElementById('commandList');
  const scoreListUL = document.getElementById('scoreList');
  const historyListUL = document.getElementById('historyList');
  const currentChallengeDiv = document.getElementById('currentChallenge');
  const currentDescriptionDiv = document.getElementById('currentDescription');
  const scoreInput = document.getElementById('scoreInput');
  const submitScoreBtn = document.getElementById('submitScoreBtn');
  const failChallengeBtn = document.getElementById('failChallengeBtn');
  const undoBtn = document.getElementById('undoBtn');
  const toggleHardcoreBtn = document.getElementById('toggleHardcoreForCurrent');
  const gameArea = document.getElementById('gameArea');
  const startGameBtn = document.getElementById('startGameBtn');
  const newPlayerNameInput = document.getElementById('newPlayerName');
  const addPlayerBtn = document.getElementById('addPlayerBtn');
  const newCommandTextInput = document.getElementById('newCommandText');
  const newCommandDescInput = document.getElementById('newCommandDesc');
  const addCommandBtn = document.getElementById('addCommandBtn');
  const toggleCommandListBtn = document.getElementById('toggleCommandList');
  const darkModeToggleBtn = document.getElementById('darkModeToggle');
  const numChallengesInput = document.getElementById('numChallengesInput');
  const startingScoreInput = document.getElementById('startingScoreInput');
  const hardcoreModeToggle = document.getElementById('hardcoreModeToggle');
  const confirmationOverlay = document.getElementById('confirmationOverlay');
  const confirmationBox = document.getElementById('confirmationBox');
  const finalResultsDiv = document.getElementById('finalResults');
  const closeConfirmationBtn = document.getElementById('closeConfirmationBtn');

  // -------------------------
  // Initialization & Load Data
  // -------------------------

  // Load all players from Firestore
  async function loadPlayers() {
    const snapshot = await db.collection('players').get();
    players = [];
    selectedPlayers.clear();
    playerButtonsDiv.innerHTML = '';
    snapshot.forEach(doc => {
      let p = { id: doc.id, name: doc.data().name, score: 0 };
      players.push(p);
    });
    renderPlayerButtons();
  }

  // Load all challenges from Firestore
  async function loadChallenges() {
    const snapshot = await db.collection('commands').get();
    challenges = [];
    commandListDiv.innerHTML = '';
    snapshot.forEach(doc => {
      let c = { id: doc.id, text: doc.data().text, description: doc.data().description || "", hardcore: doc.data().hardcore || false };
      challenges.push(c);
    });
    renderChallengeList();
  }

  // Load game history for display (not all past games, just current game's)
  function renderHistory() {
    historyListUL.innerHTML = '';
    gameHistory.forEach((h, idx) => {
      let player = players.find(p => p.id === h.playerId);
      let challenge = challenges.find(c => c.id === h.challengeId);
      let actionDesc = h.action === 'fail' ? 'Failed' : h.action === 'undo' ? 'Undo' : `Scored +${h.scoreChange}`;
      let li = document.createElement('li');
      li.textContent = `Turn ${idx + 1}: ${player ? player.name : 'Unknown Player'} - "${challenge ? challenge.text : 'Unknown Challenge'}" → ${actionDesc}`;
      historyListUL.appendChild(li);
    });
  }

  // -------------------------
  // Rendering functions
  // -------------------------

  // Render player buttons with selection toggle and edit/delete controls
  function renderPlayerButtons() {
    playerButtonsDiv.innerHTML = '';
    players.forEach(p => {
      const btn = document.createElement('button');
      btn.textContent = p.name;
      btn.className = 'player-btn deselected';
      btn.title = `Click to select/deselect player "${p.name}"`;

      // Initially deselected - user clicks to select
      btn.onclick = () => {
        if (selectedPlayers.has(p.id)) {
          selectedPlayers.delete(p.id);
          btn.classList.remove('selected');
          btn.classList.add('deselected');
        } else {
          selectedPlayers.add(p.id);
          btn.classList.remove('deselected');
          btn.classList.add('selected');
        }
      };

      // Add edit/delete buttons for each player
      const editBtn = document.createElement('button');
      editBtn.textContent = 'Edit';
      editBtn.className = 'edit-btn';
      editBtn.onclick = (e) => {
        e.stopPropagation();
        editPlayer(p);
      };

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.className = 'delete-btn';
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        deletePlayer(p);
      };

      btn.appendChild(editBtn);
      btn.appendChild(deleteBtn);

      playerButtonsDiv.appendChild(btn);
    });
  }

  // Render the list of challenges with edit/delete and hardcore toggle
  function renderChallengeList() {
    commandListDiv.innerHTML = '';
    challenges.forEach(c => {
      const div = document.createElement('div');
      div.style.marginBottom = '12px';

      // Challenge text with hardcore highlight
      const textSpan = document.createElement('span');
      textSpan.textContent = c.text;
      textSpan.style.fontWeight = 'bold';
      if (c.hardcore) {
        textSpan.classList.add('hardcore');
        textSpan.title = "Hardcore challenge";
      }
      div.appendChild(textSpan);

      // Description below
      if (c.description) {
        const descSpan = document.createElement('div');
        descSpan.textContent = c.description;
        descSpan.style.fontStyle = 'italic';
        descSpan.style.fontSize = '0.9em';
        descSpan.style.marginTop = '4px';
        div.appendChild(descSpan);
      }

      // Buttons: Edit, Delete, Toggle Hardcore
      const editBtn = document.createElement('button');
      editBtn.textContent = 'Edit';
      editBtn.className = 'edit-btn';
      editBtn.onclick = () => editCommand(c);

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.className = 'delete-btn';
      deleteBtn.onclick = () => deleteCommand(c);

      const hardcoreToggleBtn = document.createElement('button');
      hardcoreToggleBtn.textContent = c.hardcore ? 'Unset Hardcore' : 'Set Hardcore';
      hardcoreToggleBtn.className = 'edit-btn';
      hardcoreToggleBtn.style.backgroundColor = c.hardcore ? '#f66' : '#6f6';
      hardcoreToggleBtn.onclick = () => toggleHardcoreChallenge(c);

      div.appendChild(editBtn);
      div.appendChild(deleteBtn);
      div.appendChild(hardcoreToggleBtn);

      commandListDiv.appendChild(div);
    });
  }

  // Update scoreboard display
  function updateScoreboard() {
    scoreListUL.innerHTML = '';
    // Show selected players only, sorted by score descending
    let playerList = Array.from(selectedPlayers).map(id => {
      return { ...players.find(p => p.id === id), score: playerScores[id] || 0 };
    });
    playerList.sort((a, b) => b.score - a.score);
    playerList.forEach(p => {
      let li = document.createElement('li');
      li.textContent = `${p.name}: ${p.score}`;
      scoreListUL.appendChild(li);
    });
  }

  // -------------------------
  // Player & Command CRUD
  // -------------------------

  // Add new player to Firebase & reload list
  async function addPlayer() {
    const name = newPlayerNameInput.value.trim();
    if (!name) {
      alert("Player name can't be empty.");
      return;
    }
    await db.collection('players').add({ name });
    newPlayerNameInput.value = '';
    await loadPlayers();
  }

  // Edit player name in Firebase
  async function editPlayer(player) {
    const newName = prompt("Edit player name:", player.name);
    if (newName !== null && newName.trim() !== "") {
      await db.collection('players').doc(player.id).update({ name: newName.trim() });
      await loadPlayers();
    }
  }

  // Delete player after confirmation
  async function deletePlayer(player) {
    if (confirm(`Delete player "${player.name}"? This action cannot be undone.`)) {
      await db.collection('players').doc(player.id).delete();
      await loadPlayers();
    }
  }

  // Add new challenge to Firebase & reload list
  async function addCommand() {
    const text = newCommandTextInput.value.trim();
    if (!text) {
      alert("Challenge text can't be empty.");
      return;
    }
    const description = newCommandDescInput.value.trim();
    await db.collection('commands').add({ text, description, hardcore: false });
    newCommandTextInput.value = '';
    newCommandDescInput.value = '';
    await loadChallenges();
  }

  // Edit challenge text & description in Firebase
  async function editCommand(command) {
    const newText = prompt("Edit challenge text:", command.text);
    if (newText === null || newText.trim() === '') return;
    const newDesc = prompt("Edit challenge description (optional):", command.description || '') || '';
    await db.collection('commands').doc(command.id).update({ text: newText.trim(), description: newDesc.trim() });
    await loadChallenges();
  }

  // Delete challenge after confirmation
  async function deleteCommand(command) {
    if (confirm(`Delete challenge "${command.text}"? This action cannot be undone.`)) {
      await db.collection('commands').doc(command.id).delete();
      await loadChallenges();
    }
  }

  // Toggle hardcore flag for challenge in Firebase
  async function toggleHardcoreChallenge(command) {
    await db.collection('commands').doc(command.id).update({ hardcore: !command.hardcore });
    await loadChallenges();
  }

  // -------------------------
  // Game Play Logic
  // -------------------------

  // Shuffle array helper
  function shuffleArray(array) {
    let arr = array.slice();
    for(let i = arr.length - 1; i > 0; i--) {
      let j = Math.floor(Math.random() * (i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Start a new game
  function startGame() {
    if (gameInProgress) {
      if (!confirm("A game is already in progress. Start new game and lose current progress?")) return;
    }

    if (selectedPlayers.size < 1) {
      alert("Select at least one player to start the game.");
      return;
    }
    if (challenges.length < 1) {
      alert("No challenges available. Add challenges before starting.");
      return;
    }

    // Setup game state
    gameInProgress = true;
    gameArea.classList.remove('hidden');
    currentRoundChallenges = [];

    // Reset scores and history
    playerScores = {};
    Array.from(selectedPlayers).forEach(id => {
      playerScores[id] = Number(startingScoreInput.value) || 0;
    });
    gameHistory = [];
    updateScoreboard();
    renderHistory();

    // Select random challenges for this game
    const numChallenges = Math.min(Number(numChallengesInput.value) || 10, challenges.length);
    // Filter challenges for hardcore if enabled (for balance)
    let availableChallenges = challenges.slice();
    currentRoundChallenges = shuffleArray(availableChallenges).slice(0, numChallenges);

    currentChallengeIndex = 0;
    currentPlayerIndex = 0;
    hardcoreModeEnabled = hardcoreModeToggle.checked;

    // Track hardcore challenges for this game
    hardcoreChallengeIds = new Set();
    if (hardcoreModeEnabled) {
      // Let's assign approx 1 hardcore challenge per 10 challenges randomly if any hardcore available
      let hardcoreCandidates = currentRoundChallenges.filter(c => c.hardcore);
      if (hardcoreCandidates.length > 0) {
        // We'll randomly select one hardcore challenge per 10 challenges in total (rounded)
        let hardcoreCount = Math.max(1, Math.floor(numChallenges / 10));
        shuffleArray(hardcoreCandidates).slice(0, hardcoreCount).forEach(c => hardcoreChallengeIds.add(c.id));
      }
    }

    renderCurrentTurn();
  }

  // Render the current challenge and player turn
  function renderCurrentTurn() {
    if (!gameInProgress) return;

    if (currentChallengeIndex >= currentRoundChallenges.length) {
      endGame();
      return;
    }

    const challenge = currentRoundChallenges[currentChallengeIndex];
    const playerId = Array.from(selectedPlayers)[currentPlayerIndex];
    const player = players.find(p => p.id === playerId);

    if (!challenge || !player) {
      // Safety fallback: end game if data inconsistent
      endGame();
      return;
    }

    currentChallengeDiv.textContent = challenge.text;
    currentDescriptionDiv.textContent = challenge.description || '';
    if (hardcoreChallengeIds.has(challenge.id)) {
      currentChallengeDiv.classList.add('hardcore');
      toggleHardcoreBtn.classList.remove('hidden');
      toggleHardcoreBtn.textContent = 'Hardcore Challenge';
      toggleHardcoreBtn.disabled = true; // disable manual toggling during game
    } else {
      currentChallengeDiv.classList.remove('hardcore');
      toggleHardcoreBtn.classList.add('hidden');
    }

    scoreInput.value = '';
    scoreInput.placeholder = `Enter score for ${player.name}`;
    scoreInput.focus();

    submitScoreBtn.textContent = `Submit Score (${player.name})`;
    failChallengeBtn.textContent = `Fail (${player.name})`;
    undoBtn.disabled = gameHistory.length === 0;

    updateScoreboard();
    renderHistory();
  }

  // Submit a successful score for current player/challenge
  function submitScore() {
    if (!gameInProgress) return;

    const score = Number(scoreInput.value);
    if (isNaN(score) || score < 0) {
      alert("Enter a valid non-negative score.");
      return;
    }

    const playerId = Array.from(selectedPlayers)[currentPlayerIndex];
    const challenge = currentRoundChallenges[currentChallengeIndex];

    // Update score and history
    playerScores[playerId] += score;
    gameHistory.push({
      playerId,
      challengeId: challenge.id,
      scoreChange: score,
      action: 'score',
      timestamp: Date.now()
    });

    advanceTurn();
  }

  // Handle fail logic: halve score or fail hardcore challenge outright
  function failChallenge() {
    if (!gameInProgress) return;

    const playerId = Array.from(selectedPlayers)[currentPlayerIndex];
    const challenge = currentRoundChallenges[currentChallengeIndex];
    const isHardcore = hardcoreChallengeIds.has(challenge.id);

    if (isHardcore) {
      // Fail means player score = 0 immediately (fail hardcore)
      playerScores[playerId] = 0;
    } else {
      // Halve player's score, rounded down
      playerScores[playerId] = Math.floor(playerScores[playerId] / 2);
    }
    gameHistory.push({
      playerId,
      challengeId: challenge.id,
      scoreChange: 0,
      action: 'fail',
      timestamp: Date.now()
    });

    advanceTurn();
  }

  // Undo last action
  function undoLastAction() {
    if (gameHistory.length === 0) return;

    const last = gameHistory.pop();

    // Rollback player score accordingly
    if (last.action === 'score') {
      playerScores[last.playerId] -= last.scoreChange;
      if (playerScores[last.playerId] < 0) playerScores[last.playerId] = 0;
    } else if (last.action === 'fail') {
      // For fail, we can't rollback exactly without history. We will reset score to what it was before fail.
      // But we don't track past scores, so let's end undo here with alert.
      alert("Undo of fail action not supported because previous scores not tracked. Please be careful!");
      gameHistory.push(last); // put back
      return;
    } else if (last.action === 'undo') {
      // This is recursive and complicated, skip undo of undo for now
      alert("Undo of undo not supported.");
      gameHistory.push(last);
      return;
    }

    // Adjust current player and challenge index back to last turn
    // Since turns advance by player, then challenge
    currentPlayerIndex--;
    if (currentPlayerIndex < 0) {
      currentChallengeIndex--;
      if (currentChallengeIndex < 0) currentChallengeIndex = 0;
      currentPlayerIndex = selectedPlayers.size - 1;
    }

    updateScoreboard();
    renderHistory();
    renderCurrentTurn();
  }

  // Advance to next player/round or end game if done
  function advanceTurn() {
    // Increment player index
    currentPlayerIndex++;
    if (currentPlayerIndex >= selectedPlayers.size) {
      currentPlayerIndex = 0;
      currentChallengeIndex++;
    }

    if (currentChallengeIndex >= currentRoundChallenges.length) {
      // Game over
      endGame();
      return;
    }

    updateScoreboard();
    renderHistory();
    renderCurrentTurn();
  }

  // End game and show confirmation
  function endGame() {
    gameInProgress = false;
    gameArea.classList.add('hidden');

    // Prepare final ranking by score descending
    let finalScores = Array.from(selectedPlayers).map(id => {
      let p = players.find(pl => pl.id === id);
      return { name: p ? p.name : 'Unknown', score: playerScores[id] || 0 };
    });
    finalScores.sort((a,b) => b.score - a.score);

    // Create HTML for final results
    let html = '<ol>';
    finalScores.forEach(p => {
      html += `<li>${p.name}: ${p.score}</li>`;
    });
    html += '</ol>';
    finalResultsDiv.innerHTML = html;
    confirmationOverlay.style.display = 'flex';

    // Reset game data after confirmation closed
  }

  // -------------------------
  // Event Listeners
  // -------------------------

  addPlayerBtn.onclick = addPlayer;
  addCommandBtn.onclick = addCommand;
  startGameBtn.onclick = startGame;
  submitScoreBtn.onclick = submitScore;
  failChallengeBtn.onclick = failChallenge;
  undoBtn.onclick = undoLastAction;
  toggleCommandListBtn.onclick = () => {
    if (commandListDiv.classList.contains('hidden')) {
      commandListDiv.classList.remove('hidden');
      toggleCommandListBtn.textContent = 'Hide Challenge List';
    } else {
      commandListDiv.classList.add('hidden');
      toggleCommandListBtn.textContent = 'Show Challenge List';
    }
  };
  darkModeToggleBtn.onclick = () => {
    document.body.classList.toggle('dark-mode');
    confirmationBox.classList.toggle('dark');
  };
  closeConfirmationBtn.onclick = () => {
    confirmationOverlay.style.display = 'none';
  };

  // Keyboard enter for score input
  scoreInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') submitScore();
  });

  // -------------------------
  // Initial load
  // -------------------------

  loadPlayers();
  loadChallenges();Here is the updated code incorporating the player **select/deselect** feature (instead of automatically including all players), while restoring the other features you requested.  

Key changes and notes:

- Players are shown with toggle buttons to select/deselect before starting the game.
- `selectedPlayers` is a **Set** that holds the currently selected player IDs.
- The game will only start if at least one player is selected.
- Player buttons have edit/delete and toggle-selection on click.
- Scores, challenges, and hardcore mode work as before.
- Undo, fail, and scoring functionality remains.
- Added comments where selection logic was added/changed.

```js
// State variables
// -------------------------
let players = [];             // All players from DB
let challenges = [];          // All challenges from DB
let selectedPlayers = new Set(); // Player IDs selected to play
let gameInProgress = false;

// Game play state
let playerScores = {};        // playerId -> current score
let gameHistory = [];         // Array of {playerId, challengeId, scoreChange, action: 'score'|'fail'|'undo'}
let currentRoundChallenges = []; // Array of challenges chosen for current game (randomly)
let currentChallengeIndex = 0;   // Index in currentRoundChallenges, current challenge
let currentPlayerIndex = 0;      // Index in selectedPlayers array for whose turn it is

// Hardcore mode settings
let hardcoreModeEnabled = false;
let hardcoreChallengeIds = new Set(); // Challenges marked hardcore for this game

// Cached DOM elements
const playerButtonsDiv = document.getElementById('playerButtons');
const commandListDiv = document.getElementById('commandList');
const scoreListUL = document.getElementById('scoreList');
const historyListUL = document.getElementById('historyList');
const currentChallengeDiv = document.getElementById('currentChallenge');
const currentDescriptionDiv = document.getElementById('currentDescription');
const scoreInput = document.getElementById('scoreInput');
const submitScoreBtn = document.getElementById('submitScoreBtn');
const failChallengeBtn = document.getElementById('failChallengeBtn');
const undoBtn = document.getElementById('undoBtn');
const toggleHardcoreBtn = document.getElementById('toggleHardcoreForCurrent');
const gameArea = document.getElementById('gameArea');
const startGameBtn = document.getElementById('startGameBtn');
const newPlayerNameInput = document.getElementById('newPlayerName');
const addPlayerBtn = document.getElementById('addPlayerBtn');
const newCommandTextInput = document.getElementById('newCommandText');
const newCommandDescInput = document.getElementById('newCommandDesc');
const addCommandBtn = document.getElementById('addCommandBtn');
const toggleCommandListBtn = document.getElementById('toggleCommandList');
const darkModeToggleBtn = document.getElementById('darkModeToggle');
const numChallengesInput = document.getElementById('numChallengesInput');
const startingScoreInput = document.getElementById('startingScoreInput');
const hardcoreModeToggle = document.getElementById('hardcoreModeToggle');
const confirmationOverlay = document.getElementById('confirmationOverlay');
const confirmationBox = document.getElementById('confirmationBox');
const finalResultsDiv = document.getElementById('finalResults');
const closeConfirmationBtn = document.getElementById('closeConfirmationBtn');

// -------------------------
// Initialization & Load Data
// -------------------------

// Load all players from Firestore
async function loadPlayers() {
  const snapshot = await db.collection('players').get();
  players = [];
  selectedPlayers.clear(); // Clear selection when loading fresh
  playerButtonsDiv.innerHTML = '';
  snapshot.forEach(doc => {
    let p = { id: doc.id, name: doc.data().name, score: 0 };
    players.push(p);
  });
  renderPlayerButtons();
}

// Load all challenges from Firestore
async function loadChallenges() {
  const snapshot = await db.collection('commands').get();
  challenges = [];
  commandListDiv.innerHTML = '';
  snapshot.forEach(doc => {
    let c = { id: doc.id, text: doc.data().text, description: doc.data().description || "", hardcore: doc.data().hardcore || false };
    challenges.push(c);
  });
  renderChallengeList();
}

// Load game history for display (not all past games, just current game's)
function renderHistory() {
  historyListUL.innerHTML = '';
  gameHistory.forEach((h, idx) => {
    let player = players.find(p => p.id === h.playerId);
    let challenge = challenges.find(c => c.id === h.challengeId);
    let actionDesc = h.action === 'fail' ? 'Failed' : h.action === 'undo' ? 'Undo' : `Scored +${h.scoreChange}`;
    let li = document.createElement('li');
    li.textContent = `Turn ${idx + 1}: ${player ? player.name : 'Unknown Player'} - "${challenge ? challenge.text : 'Unknown Challenge'}" → ${actionDesc}`;
    historyListUL.appendChild(li);
  });
}

// -------------------------
// Rendering functions
// -------------------------

// Render player buttons with selection toggle and edit/delete controls
function renderPlayerButtons() {
  playerButtonsDiv.innerHTML = '';
  players.forEach(p => {
    const btn = document.createElement('button');
    btn.textContent = p.name;
    btn.className = selectedPlayers.has(p.id) ? 'player-btn selected' : 'player-btn deselected';
    btn.title = `Click to select/deselect player "${p.name}"`;

    // Toggle selection on click
    btn.onclick = () => {
      if (selectedPlayers.has(p.id)) {
        selectedPlayers.delete(p.id);
        btn.classList.remove('selected');
        btn.classList.add('deselected');
      } else {
        selectedPlayers.add(p.id);
        btn.classList.remove('deselected');
        btn.classList.add('selected');
      }
    };

    // Edit button
    const editBtn = document.createElement('button');
    editBtn.textContent = 'Edit';
    editBtn.className = 'edit-btn';
    editBtn.onclick = (e) => {
      e.stopPropagation();
      editPlayer(p);
    };

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.className = 'delete-btn';
    deleteBtn.onclick = (e) => {
      e.stopPropagation();
      deletePlayer(p);
    };

    btn.appendChild(editBtn);
    btn.appendChild(deleteBtn);

    playerButtonsDiv.appendChild(btn);
  });
}

// Render the list of challenges with edit/delete and hardcore toggle
function renderChallengeList() {
  commandListDiv.innerHTML = '';
  challenges.forEach(c => {
    const div = document.createElement('div');
    div.style.marginBottom = '12px';

    // Challenge text with hardcore highlight
    const textSpan = document.createElement('span');
    textSpan.textContent = c.text;
    textSpan.style.fontWeight = 'bold';
    if (c.hardcore) {
      textSpan.classList.add('hardcore');
      textSpan.title = "Hardcore challenge";
    }
    div.appendChild(textSpan);

    // Description below
    if (c.description) {
      const descSpan = document.createElement('div');
      descSpan.textContent = c.description;
      descSpan.style.fontStyle = 'italic';
      descSpan.style.fontSize = '0.9em';
      descSpan.style.marginTop = '4px';
      div.appendChild(descSpan);
    }

    // Buttons: Edit, Delete, Toggle Hardcore
    const editBtn = document.createElement('button');
    editBtn.textContent = 'Edit';
    editBtn.className = 'edit-btn';
    editBtn.onclick = () => editCommand(c);

    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.className = 'delete-btn';
    deleteBtn.onclick = () => deleteCommand(c);

    const hardcoreToggleBtn = document.createElement('button');
    hardcoreToggleBtn.textContent = c.hardcore ? 'Unset Hardcore' : 'Set Hardcore';
    hardcoreToggleBtn.className = 'edit-btn';
    hardcoreToggleBtn.style.backgroundColor = c.hardcore ? '#f66' : '#6f6';
    hardcoreToggleBtn.onclick = () => toggleHardcoreChallenge(c);

    div.appendChild(editBtn);
    div.appendChild(deleteBtn);
    div.appendChild(hardcoreToggleBtn);

    commandListDiv.appendChild(div);
  });
}

// Update scoreboard display
function updateScoreboard() {
  scoreListUL.innerHTML = '';
  // Show selected players only, sorted by score descending
  let playerList = Array.from(selectedPlayers).map(id => {
    return { ...players.find(p => p.id === id), score: playerScores[id] || 0 };
  });
  playerList.sort((a, b) => b.score - a.score);
  playerList.forEach(p => {
    let li = document.createElement('li');
    li.textContent = `${p.name}: ${p.score}`;
    scoreListUL.appendChild(li);
  });
}

// -------------------------
// Player & Command CRUD
// -------------------------

// Add new player to Firebase & reload list
async function addPlayer() {
  const name = newPlayerNameInput.value.trim();
  if (!name) {
    alert("Player name can't be empty.");
    return;
  }
  await db.collection('players').add({ name });
  newPlayerNameInput.value = '';
  await loadPlayers();
}

// Edit player name in Firebase
async function editPlayer(player) {
  const newName = prompt("Edit player name:", player.name);
  if (newName !== null && newName.trim() !== "") {
    await db.collection('players').doc(player.id).update({ name: newName.trim() });
    await loadPlayers();
  }
}

// Delete player after confirmation
async function deletePlayer(player) {
  if (confirm(`Delete player "${player.name}"? This action cannot be undone.`)) {
    await db.collection('players').doc(player.id).delete();
    await loadPlayers();
  }
}

// Add new challenge to Firebase & reload list
async function addCommand() {
  const text = newCommandTextInput.value.trim();
  if (!text) {
    alert("Challenge text can't be empty.");
    return;
  }
  const description = newCommandDescInput.value.trim();
  await db.collection('commands').add({ text, description, hardcore: false });
  newCommandTextInput.value = '';
  newCommandDescInput.value = '';
  await loadChallenges();
}

// Edit challenge text & description in Firebase
async function editCommand(command) {
  const newText = prompt("Edit challenge text:", command.text);
  if (newText === null || newText.trim() === '') return;
  const newDesc = prompt("Edit challenge description (optional):", command.description || '') || '';
  await db.collection('commands').doc(command.id).update({ text: newText.trim(), description: newDesc.trim() });
  await loadChallenges();
}

// Delete challenge after confirmation
async function deleteCommand(command) {
  if (confirm(`Delete challenge "${command.text}"? This action cannot be undone.`)) {
    await db.collection('commands').doc(command.id).delete();
    await loadChallenges();
  }
}

// Toggle hardcore flag for challenge in Firebase
async function toggleHardcoreChallenge(command) {
  await db.collection('commands').doc(command.id).update({ hardcore: !command.hardcore });
  await loadChallenges();
}

// -------------------------
// Game Play Logic
// -------------------------

// Shuffle array helper
function shuffleArray(array) {
  let arr = array.slice();
  for(let i = arr.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// Start a new game
function startGame() {
  if (gameInProgress) {
    if (!confirm("A game is already in progress. Start new game and lose current progress?")) return;
  }

  if (selectedPlayers.size < 1) {
    alert("Select at least one player to start the game.");
    return;
  }
  if (challenges.length < 1) {
    alert("No challenges available. Add challenges before starting.");
    return;
  }

  // Setup game state
  gameInProgress = true;
  gameArea.classList.remove('hidden');
  currentRoundChallenges = [];

  // Reset scores and history
  playerScores = {};
  Array.from(selectedPlayers).forEach(id => {
    playerScores[id] = Number(startingScoreInput.value) || 0;
  });
  gameHistory = [];
  updateScoreboard();
  renderHistory();

  // Select random challenges for this game
  const numChallenges = Math.min(Number(numChallengesInput.value) || 10, challenges.length);
  // Filter challenges for hardcore if enabled (for balance)
  let availableChallenges = challenges.slice();
  currentRoundChallenges = shuffleArray(availableChallenges).slice(0, numChallenges);

  currentChallengeIndex = 0;
  currentPlayerIndex = 0;
  hardcoreModeEnabled = hardcoreModeToggle.checked;

  // Track hardcore challenges for this game
  hardcoreChallengeIds = new Set();
  if (hardcoreModeEnabled) {
    // Let's assign approx 1 hardcore challenge per 10 challenges randomly if any hardcore available
    let hardcoreCandidates = currentRoundChallenges.filter(c => c.hardcore);
    if (hardcoreCandidates.length > 0) {
      let hardcoreCount = Math.max(1, Math.floor(numChallenges / 10));
      shuffleArray(hardcoreCandidates).slice(0, hardcoreCount).forEach(c => hardcoreChallengeIds.add(c.id));
    }
  }

  renderCurrentTurn();
}

// Render the current challenge and player turn
function renderCurrentTurn() {
  if (!gameInProgress) return;

  if (currentChallengeIndex >= currentRoundChallenges.length) {
    endGame();
    return;
  }

  const challenge = currentRoundChallenges[currentChallengeIndex];
  const playerId = Array.from(selectedPlayers)[currentPlayerIndex];
  const player = players.find(p => p.id === playerId);

  if (!challenge || !player) {
    // Safety fallback: end game if data inconsistent
    endGame();
    return;
  }

  currentChallengeDiv.textContent = challenge.text;
  currentDescriptionDiv.textContent = challenge.description || '';
  if (hardcoreChallengeIds.has(challenge.id)) {
    currentChallengeDiv.classList.add('hardcore');
    toggleHardcoreBtn.classList.remove('hidden');
    toggleHardcoreBtn.textContent = 'Hardcore Challenge';
    toggleHardcoreBtn.disabled = true; // disable manual toggling during game
  } else {
    currentChallengeDiv.classList.remove('hardcore');
    toggleHardcoreBtn.classList.add('hidden');
  }

  scoreInput.value = '';
  scoreInput.placeholder = `Enter score for ${player.name}`;
  scoreInput.focus();

  submitScoreBtn.textContent = `Submit Score (${player.name})`;
  failChallengeBtn.textContent = `Fail (${player.name})`;
  undoBtn.disabled = gameHistory.length === 0;

  updateScoreboard();
  renderHistory();
}

// Submit a successful score for current player/challenge
function submitScore() {
  if (!gameInProgress) return;

  const score = Number(scoreInput.value);
  if (isNaN(score) || score < 0) {
    alert("Enter a valid non-negative score.");
    return;
  }

  const playerId = Array.from(selectedPlayers)[currentPlayerIndex];
  const challenge = currentRoundChallenges[currentChallengeIndex];

  playerScores[playerId] += score;
  gameHistory.push({
    playerId,
    challengeId: challenge.id,
    scoreChange: score,
    action: 'score',
    timestamp: Date.now()
  });

  advanceTurn();
}

// Handle fail logic: halve score or fail hardcore challenge outright
function failChallenge() {
  if (!gameInProgress) return;

  const playerId = Array.from(selectedPlayers)[currentPlayerIndex];
  const challenge = currentRoundChallenges[currentChallengeIndex];
  const isHardcore = hardcoreChallengeIds.has(challenge.id);

  if (isHardcore) {
    playerScores[playerId] = 0;
  } else {
    playerScores[playerId] = Math.floor(playerScores[playerId] / 2);
  }
  gameHistory.push({
    playerId,
    challengeId: challenge.id,
    scoreChange: 0,
    action: 'fail',
    timestamp: Date.now()
  });

  advanceTurn();
}

// Undo last action
function undoLastAction() {
  if (gameHistory.length === 0) return;

  const last = gameHistory.pop();

  if (last.action === 'score') {
    playerScores[last.playerId] -= last.scoreChange;
    if (playerScores[last.playerId] < 0) playerScores[last.playerId] = 0;
  } else if (last.action === 'fail') {
    alert("Undo of fail action not supported due to no previous score history. Be careful!");
    gameHistory.push(last);
    return;
  } else if (last.action === 'undo') {
    alert("Undo of undo not supported.");
    gameHistory.push(last);
    return;
  }

  // Move back one turn
  currentPlayerIndex--;
  if (currentPlayerIndex < 0) {
    currentChallengeIndex--;
    if (currentChallengeIndex < 0) currentChallengeIndex = 0;
    currentPlayerIndex = selectedPlayers.size - 1;
  }

  updateScoreboard();
  renderHistory();
  renderCurrentTurn();
}

// Advance to next player/challenge or end game if done
function advanceTurn() {
  currentPlayerIndex++;
  if (currentPlayerIndex >= selectedPlayers.size) {
    currentPlayerIndex = 0;
    currentChallengeIndex++;
  }

  if (currentChallengeIndex >= currentRoundChallenges.length) {
    endGame();
    return;
  }

  updateScoreboard();
  renderHistory();
  renderCurrentTurn();
}

// End game and show final scores
function endGame() {
  gameInProgress = false;
  gameArea.classList.add('hidden');

  let finalScores = Array.from(selectedPlayers).map(id => {
    let p = players.find(pl => pl.id === id);
    return { name: p ? p.name : 'Unknown', score: playerScores[id] || 0 };
  });
  finalScores.sort((a,b) => b.score - a.score);

  let html = '<ol>';
  finalScores.forEach(p => {
    html += `<li>${p.name}: ${p.score}</li>`;
  });
  html += '</ol>';
  finalResultsDiv.innerHTML = html;
  confirmationOverlay.style.display = 'flex';
}

// -------------------------
// Event Listeners
// -------------------------

addPlayerBtn.onclick = addPlayer;
addCommandBtn.onclick = addCommand;
startGameBtn.onclick = startGame;
submitScoreBtn.onclick = submitScore;
failChallengeBtn.onclick = failChallenge;
undoBtn.onclick = undoLastAction;
toggleCommandListBtn.onclick = () => {
  if (commandListDiv.classList.contains('hidden')) {
    commandListDiv.classList.remove('hidden');
    toggleCommandListBtn.textContent = 'Hide Challenge List';
  } else {
    commandListDiv.classList.add('hidden');
    toggleCommandListBtn.textContent = 'Show Challenge List';
  }
};
darkModeToggleBtn.onclick = () => {
  document.body.classList.toggle('dark-mode');
  confirmationBox.classList.toggle('dark');
};
closeConfirmationBtn.onclick = () => {
  confirmationOverlay.style.display = 'none';
};

scoreInput.addEventListener('keydown', e => {
  if (e.key === 'Enter') submitScore();
});

// -------------------------
// Initial load
// -------------------------
loadPlayers();
loadChallenges();

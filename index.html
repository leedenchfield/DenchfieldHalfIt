<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Denchfield Half-It Challenge!</title>
  <link rel="stylesheet" href="style/style.css" />

  <!-- Firebase libraries just adding this to force an update-->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
</head>
<body>
  <button id="darkModeToggle">Toggle Dark Mode</button>
  <h1>Denchfield Half-It Challenge!</h1>

  <!-- End-Game Modal â€” moved to top for early availability -->
  <div id="endGameModal" class="modal hidden">
    <div class="modal-content">
      <h2>Game Over!</h2>
      <ul id="finalScoreList"></ul>
      <button id="closeEndGameBtn" class="btn btn-primary">Close</button>
    </div>
  </div>

<div id="setupContainer">

  <!-- Player Section -->
  <section id="playerSection">
    <h2>ğŸ‘¥ Players</h2>
    <div id="playerButtons"></div>
    <input id="newPlayerName" placeholder="Enter player name" />
    <button onclick="addPlayer()">Add Player</button>
  </section>

  <!-- Challenge Section -->
  <section id="challengeSection">
    <h2>ğŸ¯Game Setup</h2>
	<button id="toggleCommandList">Show challenges</button>
	<!-- Toggle Button for Add Challenge -->
	<button id="showAddChallengeBtn">Add New Challenge</button>

	<!-- Hidden Challenge Input Form -->
	<div id="addChallengeForm" style="display: none; margin-top: 10px;">
	  <input id="newCommandText" placeholder="New challenge text" />
	  <input id="newCommandDesc" placeholder="Optional description" />
	  <input id="newCommandCate" placeholder="Category" />

		<!-- New Child-Safe Checkbox -->
		<label style="margin-left: 5px;">
			<input type="checkbox" id="newCommandSafe" />
			Child-safe
		</label>

	  <button onclick="addCommand()">Add Challenge</button>
	</div>

	<!-- Adds category filter -->
	<div id="categoryFilterContainer" style="display: none; margin: 10px 0;">
	  <label for="categoryFilter"><strong>Filter by Category:</strong></label>
	  <select id="categoryFilter">
		<option value="">All Categories</option>
	  </select>
	</div>
	<div id="commandList" style="display: none;"></div>
  </section>

  <!-- Game setup controls -->
  <section id="gameControls">
	<div id="challengeCountControl" class="inline-control-group">
	  <label for="numChallenges" style="min-width: 180px;"><strong>Challenges per Game:</strong></label>
	  <button id="decreaseChallengeBtn">âˆ’</button>
	  <input type="number" inputmode="numeric" id="numChallenges" min="1" max="50" value="10" style="width: 60px;" />
	  <button id="increaseChallengeBtn">+</button>
	</div>
	<div style="margin-top: 10px;">
	<label for="startingScore"><strong>Starting Score (optional, default 0):</strong></label><br />
	<input type="number" inputmode="numeric" id="startingScore" min="0" max="500" value="0" />
	</div>
	<details id="specialRulesPanel">
	   <summary><h2 style="display: inline; cursor: pointer;">ğŸ² Gameplay Modifiers</h2></summary>
	  <div style="margin-top: 10px; padding-left: 10px;">
		<div class="toggle-group">
			<label class="switch-label">
			<input type="checkbox" id="childSafeMode" />
			<span class="switch-slider"></span>
			<span class="label-text">ğŸ§’ Child-Safe Mode</span>
			</label>
		<div class="mode-toggle-row">
		<label class="switch-label">
			<input type="checkbox" id="hardcoreMode" />
			<span class="switch-slider"></span>
			<span class="label-text">ğŸ”¥ Hardcore Mode</span>
		</label>
		<div id="hardcoreControlBox" class="inline-control-group hidden" style="margin-left: auto;">
		<button id="decreaseHardcoreRoundsBtn">âˆ’</button>
		<input type="number" id="hardcoreChaosCount" min="0" value="1" />
		<button id="increaseHardcoreRoundsBtn">+</button>
		</div>
		</div>

		<div class="mode-toggle-row">
		<label class="switch-label">
			<input type="checkbox" id="jokerMode" />
			<span class="switch-slider"></span>
			<span class="label-text">ğŸƒ Joker Mode</span>
		</label>
		<div id="jokerControlBox" class="inline-control-group hidden" style="margin-left: auto;">
		<button id="decreaseJokerRoundsBtn">âˆ’</button>
		<input type="number" id="jokerChaosCount" min="0" value="1" />
		<button id="increaseJokerRoundsBtn">+</button>
		</div>
		</div>

		<label class="switch-label">
			<input type="checkbox" id="doubleTroubleMode" />
			<span class="switch-slider"></span>
			<span class="label-text">ğŸ’¥ Double Trouble</span>
		</label>

		<label class="switch-label">
			<input type="checkbox" id="streakBonusMode" />
			<span class="switch-slider"></span>
			<span class="label-text">ğŸ”¥ Streak Bonus</span>
		</label>

		<label class="switch-label">
			<input type="checkbox" id="driftMode" />
			<span class="switch-slider"></span>
			<span class="label-text">ğŸŒ«ï¸ Percentage Mode</span>
		</label>

		<label class="switch-label">
			<input type="checkbox" id="chaosMode" />
			<span class="switch-slider"></span>
			<span class="label-text">ğŸŒ€ Chaos Mode</span>
		</label>
		</div>
		<br />
	  </div>
	</details>
  </section>
  
    <!-- Category Controls -->
  <section id="categoryControls">
    <h3>ğŸ“¦ Challenge Categories</h3>
    <div id="categoryInputs"></div>
    <div class="category-summary" id="categorySummary"></div>
  </section>

  <button id="startGameBtn" class="hidden">ğŸ¯ Let's Play!</button>
</div>

  <!-- Game area -->
  <section id="gameArea" class="hidden">
  <h3>ğŸ¯ Let's Play!</h3>
    <div id="currentTurnInfo"></div>
    <div id="currentChallengeText"></div>
    <div id="scoreInputArea">
	<input type="number" inputmode="numeric" id="scoreInput"  min="0" placeholder="Enter score for this turn" />
    </div>
	
	<div id="scoreButtonsArea"></div>

    <div id="gameActionButtons">
      <button id="submitScoreBtn">Submit Score</button>
      <button class="fail-btn">Fail Challenge</button>
    </div>
  </section>

  <!-- Undo area -->
	<section id="undo" class="hidden">
		<div id="undoWrapper">
			<button class="undo-btn">Undo Last Action</button>
		</div>
	</section>

  <!-- Scoreboard -->
  <section id="scoreboard" class="hidden">
    <h3>ğŸ“Š Scoreboard</h3>
    <ul id="scoreList"></ul>
	 <button id="endGameBtn" class="end-game-btn" style="margin-top: 10px;">End Game</button>
  </section>

  <!-- History -->
  <section id="historyArea" class="hidden">
    <h3>ğŸ“œ Game History</h3>
    <ul id="historyList"></ul>
  </section>

<script>
  // Firebase config & init
  const firebaseConfig = {
    apiKey: "AIzaSyAusKA2YiJTelSm54EJfRbVJMk0M6mh_WM",
    authDomain: "denchfield-half-it.firebaseapp.com",
    projectId: "denchfield-half-it",
    storageBucket: "denchfield-half-it.firebasestorage.app",
    messagingSenderId: "494344468882",
    appId: "1:494344468882:web:7a1f0d2ac938627206e94b",
    measurementId: "G-ZQQM5PNWPV"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // State
  let players = [];
  let activePlayers = [];
  let commands = [];
  let selectedPlayers = new Set();
  let gameStarted = false;
  let doubleTroubleEnabled = false;
  let streakBonusEnabled = false;
  let playerStreaks = {};
  let chaosModeEnabled = false;
  let jokerRounds = [];
  let hardcoreRounds = [];
  let driftModeEnabled = false;
  let categoryRequirements = {}; // tracks how many challenges per category
  let childSafeModeEnabled = false;
  let currentGameChallenges = []; // challenges selected for this game (unique, random)
  let currentChallengeIndex = 0;
  let currentPlayerIndex = 0;
  let lastActionsStack = []; // undo stack
  	// lastActionsStack entries: {
	//   playerIndex, oldScore, oldStreak,
	//   prevPlayerIndex, prevChallengeIndex,
	//   historyLength
	// }
  let gameHistory = [];

  // UI Elements
  const playerButtonsDiv = document.getElementById("playerButtons");
  const commandListDiv = document.getElementById("commandList");
  const scoreList = document.getElementById("scoreList");
  const historyList = document.getElementById("historyList");
  const startGameBtn = document.getElementById("startGameBtn");
  const gameArea = document.getElementById("gameArea");
  const currentTurnInfo = document.getElementById("currentTurnInfo");
  const currentChallengeText = document.getElementById("currentChallengeText");
  const scoreInput = document.getElementById("scoreInput");
  const submitScoreBtn = document.getElementById("submitScoreBtn");
  const failBtn = document.querySelector(".fail-btn");
  const undoBtn = document.querySelector(".undo-btn");
  const darkModeToggle = document.getElementById("darkModeToggle");
  const toggleCommandListBtn = document.getElementById("toggleCommandList");
  const newPlayerNameInput = document.getElementById("newPlayerName");
  const categoryInputsDiv = document.getElementById("categoryInputs");
  const categorySummaryDiv = document.getElementById("categorySummary");

  // --- Utility ---

  function savePlayersToFirebase() {
    // Store players as a collection "players" with doc id = name (simplification)
    const batch = db.batch();
    players.forEach(p => {
      const docRef = db.collection("players").doc(p.name);
      batch.set(docRef, { name: p.name, score: p.score });
    });
    batch.commit();
  }

  function saveHistoryToFirebase() {
    // Store game history array as a single doc for simplicity
    db.collection("gameData").doc("history").set({ history: gameHistory });
  }

  function loadPlayersFromFirebase() {
    return db.collection("players").get().then(snapshot => {
      players = [];
      snapshot.forEach(doc => {
        const p = doc.data();
        players.push({ name: p.name, score: p.score });
      });
      updatePlayerButtons();
      updateScoreboard();
    });
  }
  
	function shuffleArray(array) {
	  for (let i = array.length - 1; i > 0; i--) {
		const j = Math.floor(Math.random() * (i + 1));
		[array[i], array[j]] = [array[j], array[i]];
	  }
	}


  function loadCommandsFromFirebase() {
    return db.collection("commands").get().then(snapshot => {
      commands = [];
      commandListDiv.innerHTML = "";
		snapshot.forEach(doc => {
		const d = doc.data();
		const raw = d.childsafe;
		const isSafe = 
			typeof raw === "boolean"
			? raw
			: String(raw || "")
				.trim()
				.toLowerCase() === "true";

		commands.push({
			id:          doc.id,
			text:        d.text,
			description: d.description || "",
			category:    d.category || "general",
			childsafe:   isSafe
		});
		});
      renderCommands();
      updateCategoryControls();
    });
  }
  
	 function populateCategoryDropdown() {
	  const categories = [...new Set(commands.map(cmd => cmd.category))].sort();
	  const dropdown = document.getElementById("categoryFilter");
	  dropdown.innerHTML = '<option value="">All Categories</option>';
	  categories.forEach(cat => {
		const option = document.createElement("option");
		option.value = cat;
		option.textContent = cat.charAt(0).toUpperCase() + cat.slice(1);
		dropdown.appendChild(option);
	  });
	}

	function refreshUI() {
	updateCategoryControls();
	updateCategorySummary();
	updateStartButtonState();
	renderCommands();
	}

  function loadHistoryFromFirebase() {
    return db.collection("gameData").doc("history").get().then(doc => {
      if (doc.exists) {
        gameHistory = doc.data().history || [];
        renderHistory();
      }
    });
  }

  // --- Category Management ---

	function updateCategoryControls() {
	  const categories = [...new Set(commands.map(c => c.category))].sort();
	  categoryInputsDiv.innerHTML = "";

	  categories.forEach(category => {
		const div = document.createElement("div");
		div.className = "category-input";

		// Label
		const label = document.createElement("label");
		label.textContent = category.charAt(0).toUpperCase() + category.slice(1) + ":";
		label.style.minWidth = "120px";

		// Minus Button
		const minusBtn = document.createElement("button");
		minusBtn.textContent = "âˆ’";
		minusBtn.style.marginRight = "5px";
		minusBtn.onclick = () => {
		// current count in the box
		const current = categoryRequirements[category] || 0;

		if (current > 0) {
			// just decrement as before
			categoryRequirements[category] = current - 1;
		} else {
			// at zero: jump to max available in that category
			const available = getFilteredCommands()
			.filter(cmd => cmd.category === category)
			.length;
			categoryRequirements[category] = available;
		}

		// reflect it in the UI + recalc everything
		input.value = categoryRequirements[category];
		updateCategorySummary();
		updateStartButtonState();
		};

		// Input field
		const input = document.createElement("input");
		input.type = "number";
		input.inputMode = "numeric";
		input.min = "0";
		input.max = "50";
		input.style.width = "60px";
		input.value = categoryRequirements[category] ?? "";
		input.addEventListener("input", () => {
		  categoryRequirements[category] = parseInt(input.value) || 0;
		  updateCategorySummary();
		  updateStartButtonState();
		});

		// Plus Button
		const plusBtn = document.createElement("button");
		plusBtn.textContent = "+";
		plusBtn.style.marginLeft = "5px";
		plusBtn.onclick = () => {
		// 1. How many challenges currently fit this category + filters
		const available = getFilteredCommands()
			.filter(cmd => cmd.category === category)
			.length;

		// 2. Whatâ€™s the current count (default 0)
		const current = categoryRequirements[category] || 0;

		// 3. Wrap logic: +1 if below max, otherwise back to 0
		if (current < available) {
			categoryRequirements[category] = current + 1;
		} else {
			categoryRequirements[category] = 0;
		}

		// 4. Push UI update and revalidate
		input.value = categoryRequirements[category];
		updateCategorySummary();
		updateStartButtonState();
		};

		div.appendChild(label);
		div.appendChild(minusBtn);
		div.appendChild(input);
		div.appendChild(plusBtn);
		categoryInputsDiv.appendChild(div);
	  });

	  updateCategorySummary();
	  updateStartButtonState();
	}

	function updateCategorySummary() {
	// 1) How many we â€œneedâ€ in total
	const totalRequired = Object
		.values(categoryRequirements)
		.reduce((sum, val) => sum + val, 0);

	// 2) How many the userâ€™s set in the â€œnumChallengesâ€ input
	const numChallenges = parseInt(
		document.getElementById("numChallenges").value, 10
	) || 0;

	// 3) Read the Child-Safe toggle, then filter the full commands pool
	const childSafeOn = document.getElementById("childSafeMode").checked;
	const filteredCommands = commands.filter(cmd =>
		!childSafeOn    // if SafeMode is off, keep allâ€¦
		|| cmd.childsafe  // â€¦otherwise only those flagged childsafe = true
	);

	// 4) Build the base summary text
	let summary = `Total selected: ${totalRequired} / ${numChallenges} challenges`;

	// 5) Per-category availability checks
	const issues = [];
	for (const [category, required] of Object.entries(categoryRequirements)) {
		const available = filteredCommands
		.filter(cmd => cmd.category === category).length;
		if (available < required) {
		issues.push(`${category}: need ${required}, have ${available}`);
		}
	}

	// 6) Append any shortfalls
	if (issues.length) {
		summary += ` | Issues: ${issues.join(", ")}`;
	}

	// 7) Flush it to the page
	document.getElementById("categorySummary").textContent = summary;
	}

  // --- Render Functions ---

	function updatePlayerButtons() {
	  playerButtonsDiv.innerHTML = "";

	  players.forEach((p, i) => {
		const wrapper = document.createElement("div");
		wrapper.style.display = "flex";
		wrapper.style.alignItems = "center";
		wrapper.style.marginBottom = "5px";
		wrapper.style.gap = "5px";

		const btn = document.createElement("button");
		btn.textContent = p.name;
		btn.className = "";
		if (selectedPlayers.has(p.name)) btn.classList.add("selected");
		if (gameStarted && i === currentPlayerIndex) btn.classList.add("current-turn");

		btn.onclick = () => {
		  if (gameStarted) return;
		  if (selectedPlayers.has(p.name)) {
			selectedPlayers.delete(p.name);
		  } else {
			selectedPlayers.add(p.name);
		  }
		  updatePlayerButtons();
		};

		btn.title = "Click to select/deselect player";
		wrapper.appendChild(btn);

		if (!gameStarted) {
		  // Edit button
		  const editBtn = document.createElement("button");
		  editBtn.textContent = "âœï¸";
		  editBtn.title = "Edit name";
		  editBtn.onclick = () => {
			const newName = prompt("Edit player name:", p.name);
			if (!newName || newName.trim() === p.name) return;
			  if (newName.length > 20) {
			alert("Player name must be 20 characters or fewer.");
			return;
			}
			if (players.some(pl => pl.name === newName.trim())) {
			  alert("Player name already exists!");
			  return;
			}

			const updatedName = newName.trim();

			// Update locally
			players[i].name = updatedName;

			// Update selected list
			if (selectedPlayers.has(p.name)) {
			  selectedPlayers.delete(p.name);
			  selectedPlayers.add(updatedName);
			}

			// Update in Firebase
			db.collection("players").doc(p.name).delete().then(() => {
			  db.collection("players").doc(updatedName).set({
				name: updatedName,
				score: p.score ?? 0
			  }).then(updatePlayerButtons);
			});
		  };
		  wrapper.appendChild(editBtn);

		  // Delete button
		  const deleteBtn = document.createElement("button");
		  deleteBtn.textContent = "ğŸ—‘ï¸";
		  deleteBtn.title = "Delete player";
		  deleteBtn.onclick = () => {
			if (!confirm(`Are you sure you want to delete ${p.name}?`)) return;

			players.splice(i, 1);
			selectedPlayers.delete(p.name);

			// Remove from Firebase
			db.collection("players").doc(p.name).delete().then(updatePlayerButtons);
		  };
		  wrapper.appendChild(deleteBtn);
		}

		playerButtonsDiv.appendChild(wrapper);
	  });

	  updateScoreboard();
	}

	function renderCommands() {
	// 1) Read the current Child-Safe Mode state
	const childSafeMode = document.getElementById("childSafeMode").checked;

	// 2) Build a source list: either all commands or only safe ones
	const source = childSafeMode
		? commands.filter(cmd => cmd.childsafe)     // only those flagged true
		: commands.slice();                         // full copy of commands

	// 3) Further filter by the selected category
	const selectedCategory = document.getElementById("categoryFilter").value;
	const filtered = selectedCategory
		? source.filter(cmd => cmd.category === selectedCategory)
		: source;

	// 4) Render
	commandListDiv.innerHTML = "";
	filtered.forEach(cmd => {
		const div = document.createElement("div");
		div.className = "commandItem";
		div.innerHTML = `
		<strong>${cmd.text}</strong><br/>
		<em>${cmd.description}</em><br/>
		<small>Category: ${cmd.category}</small>
		`;

		const editBtn = document.createElement("button");
		editBtn.className = "edit-btn";
		editBtn.textContent = "Edit";
		editBtn.onclick = () => editCommand(cmd);

		const deleteBtn = document.createElement("button");
		deleteBtn.className = "delete-btn";
		deleteBtn.textContent = "Delete";
		deleteBtn.onclick = () => deleteCommand(cmd.id);

		div.appendChild(editBtn);
		div.appendChild(deleteBtn);

		commandListDiv.appendChild(div);
	});
	}

// Re-run renderCommands() whenever Child-Safe Mode toggles:
document
  .getElementById("childSafeMode")
  .addEventListener("change", renderCommands);

// Also re-render when the category dropdown changes:
document
  .getElementById("categoryFilter")
  .addEventListener("change", renderCommands);

	function updateScoreboard() {
	  scoreList.innerHTML = "";

	  if (!gameStarted) return; // â›” Prevent showing scores before game

	  activePlayers.forEach((p, i) => {
		const li = document.createElement("li");
		let marker = i === currentPlayerIndex ? " ğŸ‘‰ " : "";
		let streakText = streakBonusEnabled && playerStreaks[p.name] >= 1 
						 ? ` ğŸ”¥ Streak x${playerStreaks[p.name]}` : "";
		li.textContent = `${marker}${p.name}: ${p.score}${streakText}`;
		scoreList.appendChild(li);
	  });
	}

  function renderHistory() {
    historyList.innerHTML = "";
    gameHistory.forEach(entry => {
      const li = document.createElement("li");
      li.textContent = entry;
      historyList.appendChild(li);
    });
  }

  // --- Player management ---

  function addPlayer() {
    const name = newPlayerNameInput.value.trim();
    if (!name) return alert("Player name cannot be empty");
	if (name.length > 20) return alert("Player name must be 20 characters or fewer");
    if (players.some(p => p.name === name)) return alert("Player name already exists");
    players.push({ name, score: 0 });
    newPlayerNameInput.value = "";
    updatePlayerButtons();
    savePlayersToFirebase();
  }

  // --- Challenge management ---

	function addCommand() {
	const text        = document.getElementById("newCommandText").value.trim();
	const description = document.getElementById("newCommandDesc").value.trim();
	const category    = document.getElementById("newCommandCate").value.trim() || "general";
	const childSafe   = document.getElementById("newCommandSafe").checked; 

	if (!text) return alert("Challenge text cannot be empty");

	db.collection("commands")
		.add({ 
		text, 
		description, 
		category, 
		childsafe: childSafe   // <-- store the boolean flag
		})
		.then(() => {
		// reload / re-render
		loadCommandsFromFirebase().then(() => {
			populateCategoryDropdown();
			renderCommands();
		});

		// clear the form
		document.getElementById("newCommandText").value = "";
		document.getElementById("newCommandDesc").value = "";
		document.getElementById("newCommandCate").value = "";
		document.getElementById("newCommandSafe").checked = false;

		// hide form
		document.getElementById("addChallengeForm").style.display = "none";
		document.getElementById("showAddChallengeBtn").textContent = "Add New Challenge";
		});
	}

	function editCommand(cmd) {
	const newText     = prompt("Edit challenge text:", cmd.text);
	if (newText === null) return;

	const newDesc     = prompt("Edit challenge description:", cmd.description);
	if (newDesc === null) return;

	const newCat      = prompt("Edit challenge category:", cmd.category);
	if (newCat === null) return;

	// Prompt for child-safe
	const safeAns     = prompt("Is this child-safe? (yes / no):", cmd.childsafe ? "yes" : "no");
	if (safeAns === null) return;
	const newSafe     = safeAns.trim().toLowerCase().startsWith("y");

	db.collection("commands").doc(cmd.id).set({
		text:        newText.trim(),
		description: newDesc.trim(),
		category:    newCat.trim() || "general",
		childsafe:   newSafe
	}).then(loadCommandsFromFirebase);
	}

  function deleteCommand(id) {
    if (confirm("Delete this challenge?")) {
      db.collection("commands").doc(id).delete().then(loadCommandsFromFirebase);
    }
  }

  // --- Game logic ---

function startGame() {
  if (gameStarted) return alert("Game already started");
  if (selectedPlayers.size === 0) return alert("Select at least one player to start");

  const numChallenges = parseInt(document.getElementById("numChallenges").value, 10);
  const startScore = parseInt(document.getElementById("startingScore").value, 10);

  if (isNaN(startScore) || startScore < 0) return alert("Starting score must be 0 or more");
  
  // âœ… Hide non game content when game is started
	document.getElementById("setupContainer").style.display = "none";

  // âœ… is child safe mode active?
	childSafeModeEnabled = document.getElementById("childSafeMode").checked;

	// 2) build one pool of onlyâ€safe or allâ€commands
	const filteredCommands = commands.filter(c =>
	!childSafeModeEnabled || c.childsafe
	);

  // âœ… Reinitialize modifier indexes for this session
  jokerRounds = [];
  hardcoreRounds = [];

  // ğŸŒª Chaos Mode flag and extra mode flags
  chaosModeEnabled = document.getElementById("chaosMode").checked;
  const useHardcore = document.getElementById("hardcoreMode").checked;
  const useJoker = document.getElementById("jokerMode").checked;
  doubleTroubleEnabled = document.getElementById("doubleTroubleMode").checked;
  streakBonusEnabled = document.getElementById("streakBonusMode").checked;
  driftModeEnabled = document.getElementById("driftMode").checked;

  // ğŸ§¼ Reset game state
  gameStarted = true;
  currentChallengeIndex = 0;
  currentPlayerIndex = 0;
  lastActionsStack = [];
  gameHistory = [];

  // ğŸ‘¥ Set up player scores for this round, but keep the full roster
	  players.forEach(p => {
		if (selectedPlayers.has(p.name)) {
		  p.score = startScore;
		} else {
		  delete p.score;      // unselected players have no score property
		}
	  });

  // Build the list of active players and shuffle turn order
  activePlayers = players.filter(p => selectedPlayers.has(p.name));
  shuffleArray(activePlayers);

  // Reset streaks only for active players
  playerStreaks = {};
  activePlayers.forEach(p => {
    playerStreaks[p.name] = 0;
  });

  currentGameChallenges = [];

	// ğŸ’£ Chaos Mode skips challenge setup
	if (chaosModeEnabled) {
	  // ğŸ”— Set chaos turn limit
	  chaosTurnLimit = isNaN(numChallenges) || numChallenges < 1 ? 10 : numChallenges;

	  // ğŸ¯ Get desired round counts

	const hardcoreChaosCount = useHardcore
	  ? parseInt(document.getElementById("hardcoreChaosCount").value, 10) || 0
	  : 0;

	const jokerChaosCount = useJoker
	  ? parseInt(document.getElementById("jokerChaosCount").value, 10) || 0
	  : 0;

	  // ğŸ² Generate eligible turn indexes
	  const eligibleIndexes = Array.from({ length: chaosTurnLimit }, (_, i) => i);
	  jokerRounds = [];
	  hardcoreRounds = [];

	  // ğŸ”¥ Assign Hardcore rounds
	  for (let i = 0; i < hardcoreChaosCount && eligibleIndexes.length > 0; i++) {
		const index = eligibleIndexes.splice(Math.floor(Math.random() * eligibleIndexes.length), 1)[0];
		hardcoreRounds.push(index);
	  }

	  // ğŸƒ Assign Joker rounds (avoid overlap)
	  for (let i = 0; i < jokerChaosCount && eligibleIndexes.length > 0; i++) {
		const index = eligibleIndexes.splice(Math.floor(Math.random() * eligibleIndexes.length), 1)[0];
		jokerRounds.push(index);
	  }
	} else {
    // ğŸ“‹ Validate category requirements
    const totalRequired = Object.values(categoryRequirements).reduce((sum, val) => sum + val, 0);
    if (totalRequired !== numChallenges) {
      return alert(`Category totals (${totalRequired}) must equal number of challenges (${numChallenges})`);
    }

    const scoringRequired = categoryRequirements["scoring"] || 0;
    const finishingRequired = categoryRequirements["finishing"] || 0;

    if (scoringRequired < 1) return alert("Must include at least 1 'scoring' challenge");
    if (finishingRequired < 1) return alert("Must include at least 1 'finishing' challenge");

    for (const category in categoryRequirements) {
      const required = categoryRequirements[category];
      const available = filteredCommands.filter(c => c.category === category).length;
      if (required > available) {
        return alert(`Not enough ${category} challenges available. Need ${required}, have ${available}`);
      }
    }

    // ğŸ² Select challenges
    const scoringChallenges = filteredCommands.filter(c => c.category === "scoring");
    const finishingChallenges = filteredCommands.filter(c => c.category === "finishing");

    const firstChallenge = scoringChallenges[Math.floor(Math.random() * scoringChallenges.length)];
    const lastChallenge = finishingChallenges[Math.floor(Math.random() * finishingChallenges.length)];
    currentGameChallenges.push(firstChallenge);

    for (const category in categoryRequirements) {
      let required = categoryRequirements[category];

      if (category === "scoring") required -= 1;
      if (category === "finishing") required -= 1;

      if (required > 0) {
        const available = filteredCommands.filter(c =>
          c.category === category &&
          c.id !== firstChallenge.id &&
          c.id !== lastChallenge.id
        );

        for (let i = 0; i < required; i++) {
          const idx = Math.floor(Math.random() * available.length);
          currentGameChallenges.push(available.splice(idx, 1)[0]);
        }
      }
    }

    const middleChallenges = currentGameChallenges.slice(1);
    shuffleArray(middleChallenges);
    currentGameChallenges = [firstChallenge, ...middleChallenges, lastChallenge];

    // ğŸ­ Joker and Hardcore assignment
	// ğŸ¯ Read desired round counts
	const hardcoreCount = useHardcore
	? parseInt(document.getElementById("hardcoreChaosCount").value, 10) || 0
	: 0;
	const jokerCount = useJoker
	? parseInt(document.getElementById("jokerChaosCount").value, 10) || 0
	: 0;

	// âœ… Reset modifier arrays
	hardcoreRounds = [];
	jokerRounds = [];

	const eligibleIndexes = currentGameChallenges
	.map((_, i) => i)
	.filter(i => i !== 0 && i !== currentGameChallenges.length - 1);

	// ğŸ”¥ Assign Hardcore rounds
	for (let i = 0; i < hardcoreCount && eligibleIndexes.length > 0; i++) {
	const index = eligibleIndexes.splice(
		Math.floor(Math.random() * eligibleIndexes.length),
		1
	)[0];
	hardcoreRounds.push(index);
	}

	// ğŸƒ Assign Joker rounds
	for (let i = 0; i < jokerCount && eligibleIndexes.length > 0; i++) {
	const index = eligibleIndexes.splice(
		Math.floor(Math.random() * eligibleIndexes.length),
		1
	)[0];
	jokerRounds.push(index);
	}
  }

  // ğŸš€ Start the game
	gameArea.classList.remove("hidden");
	document.getElementById("undo").classList.remove("hidden");
	document.getElementById("scoreboard").classList.remove("hidden");
	document.getElementById("historyArea").classList.remove("hidden");
	updatePlayerButtons();
	updateScoreboard();
	renderHistory();
	updateTurnDisplay();
}

  // Display whose turn it is and current challenge
	function updateTurnDisplay() {
	  if (!gameStarted) {
		currentTurnInfo.textContent = "";
		currentChallengeText.textContent = "";
		return;
	  }

	  const isChaosEnd = chaosModeEnabled && currentChallengeIndex >= chaosTurnLimit;
	  const isNormalEnd = !chaosModeEnabled && currentChallengeIndex >= currentGameChallenges.length;

	  if (isChaosEnd || isNormalEnd) {
		endGame();
		return;
	  }

	  const player = activePlayers[currentPlayerIndex];
	  let challenge;

		if (chaosModeEnabled) {
			const pool = commands.filter(c =>
			!childSafeModeEnabled || c.childsafe
			);

		if (pool.length === 0) {
		  currentChallengeText.textContent = "âš ï¸ No challenges available!";
		  return;
		}
		challenge = pool[Math.floor(Math.random() * pool.length)];
		currentGameChallenges[currentChallengeIndex] = challenge; // save for history
	  } else {
		challenge = currentGameChallenges[currentChallengeIndex];
	  }

	  const challengeNumber = currentChallengeIndex + 1;
	  const totalChallenges = chaosModeEnabled ? chaosTurnLimit : currentGameChallenges.length;

	  const modifiers = [];
		const isHardcore = hardcoreRounds.includes(currentChallengeIndex);
		const isJoker    = jokerRounds.includes(currentChallengeIndex);

		if (isHardcore) modifiers.push("ğŸ”¥ HARDCORE");
		if (isJoker) modifiers.push("ğŸƒ JOKER");

	  const extra = modifiers.length > 0 ? ` [${modifiers.join(" + ")}]` : "";

	  currentTurnInfo.textContent = `Current Turn: ${player.name}`;
	  currentChallengeText.textContent = `Challenge ${challengeNumber} of ${totalChallenges}: "${challenge.text}" (${challenge.description})${extra}`;

	  renderScoringButtons(challenge.text);
	  scoreInput.value = "";
	  scoreInput.focus();
	  updatePlayerButtons();
	  updateScoreboard();
	}

  // Handle submitting score for current player/challenge
	function submitScore() {
	//const confirmSubmit = confirm("Submit this score?");
	//if (!confirmSubmit) return;
	if (!gameStarted) return;
	const val = scoreInput.value.trim();
	if (!val) return alert("Please enter a score");
	let scoreVal = parseInt(val, 10);
	if (isNaN(scoreVal) || scoreVal < 0) return alert("Score must be non-negative");

	// â”€â”€ SNAPSHOT before any changes:
	const player = activePlayers[currentPlayerIndex];
	const oldScore = player.score;
	const oldStreak = playerStreaks[player.name];
	const snapshot = {
		playerIndex: currentPlayerIndex,
		oldScore,
		oldStreak,
		prevPlayerIndex: currentPlayerIndex,
		prevChallengeIndex: currentChallengeIndex,
		historyLength: gameHistory.length
	};


    // Check for Joker challenge
		let finalScore = scoreVal;
		const challengeText = currentGameChallenges[currentChallengeIndex]?.text || "";
		const isHardcore = hardcoreRounds.includes(currentChallengeIndex);
		const isJoker    = jokerRounds.includes(currentChallengeIndex);
		const isDoubleTrouble = doubleTroubleEnabled &&
		  scoreVal === getMaxPossibleScoreForChallenge(challengeText);

		if (isJoker && isDoubleTrouble) {
		  finalScore *= 4;
		    showScorePop(finalScore, false, "mega-combo");
		  gameHistory.push(`ğŸ­ğŸ’¥ MEGA COMBO! ${player.name} hit max score on a JOKER challenge â€” score QUADRUPLED to ${finalScore}!`);
		} else if (isJoker) {
		  finalScore *= 2;
		  	showScorePop(finalScore, false, "joker");
		  gameHistory.push(`ğŸƒ JOKER! ${player.name} scored double points: ${finalScore}`);
		} else if (isDoubleTrouble) {
		  finalScore *= 2;
		  	showScorePop(finalScore, false, "double-trouble");
		  gameHistory.push(`ğŸ’¥ DOUBLE TROUBLE! ${player.name} hit the max and scored ${finalScore}`);
		} else {
		showScorePop(finalScore);
		}


		player.score += finalScore;
		//showScorePop(finalScore);
		if (navigator.vibrate) navigator.vibrate(200); // 200ms buzz on success

		// Increment streak
		if (streakBonusEnabled) {
		  playerStreaks[player.name] = (playerStreaks[player.name] || 0) + 1;

		  if (playerStreaks[player.name] >= 3) {
			player.score += 20;
			scoreVal += 20; // Add bonus to scoreVal for history
				showScorePop(20, false, "streak");
			gameHistory.push(`ğŸ”¥ STREAK BONUS! ${player.name} completed 3 in a row and earned +20 points`);
			playerStreaks[player.name] = 0; // Reset streak
		  }
		}

		// âœ” Log to history
		gameHistory.push(`${player.name} scored ${scoreVal} on challenge "${currentGameChallenges[currentChallengeIndex].text}" (Total: ${player.score})`);
		// â”€â”€ PUSH SNAPSHOT to undo stack â”€â”€
		lastActionsStack.push(snapshot);
		saveHistoryToFirebase();
		renderHistory();
		showTurnFlash("success");
		nextTurn();
		}

  // Handle fail challenge (half points rounded up, min 1, unless already 0)
	function failChallenge() {
	//const confirmFail = confirm("Fail Challenge?");
	//if (!confirmFail) return;
	if (!gameStarted) return;

	const player = activePlayers[currentPlayerIndex];

	// Re-introduce oldScore and oldStreak locally
	const oldScore = player.score;
	const oldStreak = playerStreaks[player.name];

	// ğŸ“¸ Build your snapshot
	const snapshot = {
		playerIndex:        currentPlayerIndex,
		oldScore:           oldScore,
		oldStreak:          oldStreak,
		prevPlayerIndex:    currentPlayerIndex,
		prevChallengeIndex: currentChallengeIndex,
		historyLength:      gameHistory.length
	};

	let newScore, message;

	// Now the rest of your fail logic can safely use oldScoreâ€¦
	const isHardcore = hardcoreRounds.includes(currentChallengeIndex);
	const isJoker    = jokerRounds.includes(currentChallengeIndex);
	const isDrift    = driftModeEnabled;

	if (isHardcore) {
		newScore = 0;
		showTurnFlash("explosion");
		showScorePop(newScore, true, "hardcore");
		message = `ğŸ”¥ ${player.name} hit a HARDCORE fail! Score reset to 0!`;

	} else if (isJoker) {
		newScore = Math.ceil(oldScore / 4) || 1;
		showScorePop(newScore, true, "joker-fail");
		message = `ğŸƒ ${player.name} hit the JOKER penalty! Score cut to ${newScore}!`;

	} else if (isDrift) {
		const percent = Math.floor(Math.random() * 41) + 25;
		const penalty = Math.round(oldScore * (percent / 100));
		newScore = Math.max(0, oldScore - penalty);
		showScorePop(`${percent}%`, true, "drift-fail");
		message = `ğŸŒ«ï¸ Percentage Penalty â€” ${player.name}'s score reduced by ${percent}% to ${newScore}.`;

	} else {
		newScore = oldScore === 0 ? 0 : Math.max(1, Math.ceil(oldScore / 2));
		showScorePop(newScore, true);
		message = `${player.name} failed and score was halved to ${newScore}.`;
	}

	// Reset streak if needed
	if (streakBonusEnabled) playerStreaks[player.name] = 0;

	// Apply score change and log history
	player.score = newScore;
	if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
	gameHistory.push(message);

	// â”€â”€ ONLY this snapshot goes on the stack â”€â”€
	lastActionsStack.push(snapshot);

	saveHistoryToFirebase();
	renderHistory();
	showTurnFlash("fail");
	nextTurn();
	}

  // Undo last action
	function undoLastAction() {
	if (lastActionsStack.length === 0) return alert("No actions to undo");
	if (!confirm("Undo last action?")) return;

	const snap = lastActionsStack.pop();

	// 1) Restore turn indices
	currentPlayerIndex   = snap.prevPlayerIndex;
	currentChallengeIndex = snap.prevChallengeIndex;

	// 2) Restore player score & streak
	activePlayers[snap.playerIndex].score = snap.oldScore;
	playerStreaks[ activePlayers[snap.playerIndex].name ] = snap.oldStreak;

	// 3) Trim history
	gameHistory.length = snap.historyLength;

	// 4) Re-render everything
	saveHistoryToFirebase();
	renderHistory();
	updateScoreboard();
	updateTurnDisplay();
	}

  // Advance turn and challenge index properly
	function nextTurn() {
	  currentPlayerIndex++;
	  if (currentPlayerIndex >= activePlayers.length) {
		currentPlayerIndex = 0;
		currentChallengeIndex++;
	  }

	  const isChaosEnd = chaosModeEnabled && currentChallengeIndex >= chaosTurnLimit;
	  const isNormalEnd = !chaosModeEnabled && currentChallengeIndex >= currentGameChallenges.length;

	  if (isChaosEnd || isNormalEnd) {
		endGame();
	  } else {
		updateTurnDisplay();
	  }

	  updateScoreboard();
	}

  // Game end logic and popup scoreboard
	  function endGame() {
	  gameStarted = false;
	  gameArea.classList.add("hidden");

	  // Sort active players by score descending
	  const sorted = [...activePlayers].sort((a, b) => b.score - a.score);

	  // Determine winner(s)
	  const topScore = sorted[0]?.score || 0;
	  const winners = sorted.filter(p => p.score === topScore).map(p => p.name);

	  // Clear scoreboard for next round
	  scoreList.innerHTML = "";

	  // Update UI and prepare for next game
	  updatePlayerButtons();
	  updateScoreboard();

	  // Show custom modal popup
	  showEndGameModal(sorted, winners);
	  
	  // Show game setup area and hide game area and scoreboard
	    // hide play UI
		gameArea.classList.add("hidden");
		document.getElementById("scoreboard").classList.add("hidden");
		document.getElementById("undo").classList.add("hidden");
		document.getElementById("historyArea").classList.add("hidden");
		// show setup UI
	  	document.getElementById("setupContainer").style.display = "block";
	}
  
  function showTurnFlash(type) {
	  const overlay = document.getElementById("turnFlashOverlay");
	  overlay.className = "turn-flash " + type;
	  overlay.style.display = "block";
	  setTimeout(() => {
		overlay.style.display = "none";
	  }, 500);
	}

	// â€”â€”â€”â€”â€”â€”â€”â€” Game-Ready Checker â€”â€”â€”â€”â€”â€”â€”â€”

	function isGameReady() {
	// 1) at least one player selected
	if (selectedPlayers.size === 0) return false;

	// 2) valid challenge count
	const num = parseInt(document.getElementById("numChallenges").value, 10);
	if (isNaN(num) || num < 1) return false;

	// 3) if not chaos mode, category totals must match
	if (!document.getElementById("chaosMode").checked) {
		const totalReq = Object.values(categoryRequirements)
							.reduce((a, b) => a + b, 0);
		if (totalReq !== num) return false;
		    // must include at least one scoring & one finishing
		if ((categoryRequirements['scoring'] || 0) < 1)    return false;
		if ((categoryRequirements['finishing'] || 0) < 1)  return false;
	}

	// 4) must have at least one command loaded
	if (commands.length === 0) return false;

	return true;
	}

	function updateStartButtonState() {
	const btn = document.getElementById("startGameBtn");
	if (isGameReady()) {
		btn.classList.remove("hidden");
	} else {
		btn.classList.add("hidden");
	}
	}


  // --- Event listeners ---
  startGameBtn.addEventListener("click", startGame);
  submitScoreBtn.addEventListener("click", submitScore);
  failBtn.addEventListener("click", failChallenge);
  undoBtn.addEventListener("click", undoLastAction);

	// â€”â€”â€”â€”â€”â€” Show/Hide â€œğŸ¯ Letâ€™s Play!â€ When Config Changes â€”â€”â€”â€”â€”â€”

	playerButtonsDiv.addEventListener("click", updateStartButtonState);
	document.getElementById("numChallenges")
			.addEventListener("input", updateStartButtonState);
	document.getElementById("chaosMode")
			.addEventListener("change", updateStartButtonState);

  // --- Modal summary ---
	  document.getElementById("closeEndGameBtn").addEventListener("click", () => {
	  document.getElementById("endGameModal").classList.add("hidden");
	  updateScoreboard();
	});
  
	  document.getElementById("showAddChallengeBtn").addEventListener("click", () => {
	  const form = document.getElementById("addChallengeForm");
	  const isVisible = form.style.display === "block";

	  form.style.display = isVisible ? "none" : "block";
	  document.getElementById("showAddChallengeBtn").textContent = isVisible
		? "Add New Challenge"
		: "Cancel";
	});

	document.getElementById("categoryFilter").addEventListener("change", renderCommands);
		darkModeToggle.addEventListener("click", () => {
		document.body.classList.toggle("dark-mode");
		const isDark = document.body.classList.contains("dark-mode");
		localStorage.setItem("darkModeEnabled", isDark ? "true" : "false");
	});
	
	document.getElementById("increaseChallengeBtn").addEventListener("click", () => {
	  const input = document.getElementById("numChallenges");
	  let val = parseInt(input.value, 10) || 0;
	  if (val < 50) {
		input.value = val + 1;
		updateCategorySummary();
		updateStartButtonState();
	  }
	});

	document.getElementById("decreaseChallengeBtn").addEventListener("click", () => {
	  const input = document.getElementById("numChallenges");
	  let val = parseInt(input.value, 10) || 0;
	  if (val > 1) {
		input.value = val - 1;
		updateCategorySummary();
		updateStartButtonState();
	  }
	});
	
	const maxRounds = parseInt(document.getElementById("numChallenges").value, 10) || 10;
	
	// ğŸ” Joker round controls
	document.getElementById("increaseJokerRoundsBtn").addEventListener("click", () => {
	  const input = document.getElementById("jokerChaosCount");
	  let val = parseInt(input.value, 10) || 0;
		if (val < maxRounds) input.value = val + 1;

	});

	document.getElementById("decreaseJokerRoundsBtn").addEventListener("click", () => {
	  const input = document.getElementById("jokerChaosCount");
	  let val = parseInt(input.value, 10) || 0;
	  if (val > 0) input.value = val - 1;
	});
	
	// ğŸ” Hardcore round controls
	document.getElementById("increaseHardcoreRoundsBtn").addEventListener("click", () => {
	  const input = document.getElementById("hardcoreChaosCount");
	  let val = parseInt(input.value, 10) || 0;
		if (val < maxRounds) input.value = val + 1;
	});

	document.getElementById("decreaseHardcoreRoundsBtn").addEventListener("click", () => {
	  const input = document.getElementById("hardcoreChaosCount");
	  let val = parseInt(input.value, 10) || 0;
	  if (val > 0) input.value = val - 1;
	});
	
	// Toggle category section when Chaos Mode is enabled
	const chaosModeCheckbox = document.getElementById("chaosMode");
	const categoryControlsSection = document.getElementById("categoryControls");

	chaosModeCheckbox.addEventListener("change", () => {
	  const isChaos = chaosModeCheckbox.checked;
	  categoryControlsSection.style.display = isChaos ? "none" : "block";
	});

	// Toggle Hardcore and Joker control boxes
	document.getElementById("hardcoreMode").addEventListener("change", e => {
	document.getElementById("hardcoreControlBox")
			.classList.toggle("hidden", !e.target.checked);
	});

	document.getElementById("jokerMode").addEventListener("change", e => {
	document.getElementById("jokerControlBox")
			.classList.toggle("hidden", !e.target.checked);
	});

	const childSafeCheckbox = document.getElementById("childSafeMode");
	childSafeCheckbox.addEventListener("change", () => {
	// update category controls (which rely on commands[])
	updateCategoryControls();

	// recalc summary (uses filtered pool inside it)
	updateCategorySummary();

	// show/hide â€œStart Gameâ€ button
	updateStartButtonState();

	// refresh the list panel
	renderCommands();
	});

	childSafeCheckbox.addEventListener("change",   refreshUI);
	categoryFilter   .addEventListener("change",   refreshUI);
	refreshUI();


	// Optional: apply visibility on page load
	if (chaosModeCheckbox.checked) {
	categoryControlsSection.style.display = "none";
	}

	toggleCommandListBtn.addEventListener("click", () => {
	  const isHidden = commandListDiv.style.display === "none";

	  // toggle visibility of challenge list
	  commandListDiv.style.display = isHidden ? "block" : "none";

	  // toggle visibility of category filter
	  const filterContainer = document.getElementById("categoryFilterContainer");
	  filterContainer.style.display = isHidden ? "block" : "none";

	  // reset the filter when hiding
	  if (!isHidden) {
		document.getElementById("categoryFilter").value = "";
		renderCommands();
	  }

	  // update button label
	  toggleCommandListBtn.textContent = isHidden
		? "Hide challenges"
		: "Show challenges";
	});

	// whenever any Â± buttons or numberâ€fields change in the category area
	categoryInputsDiv.addEventListener("click", updateStartButtonState);
	categoryInputsDiv.addEventListener("input", updateStartButtonState);
  
  // Update category summary when number of challenges changes
  document.getElementById("numChallenges").addEventListener("input", updateCategorySummary);
  
const endGameBtn = document.getElementById("endGameBtn");

	function endGameEarly() {
	  if (!gameStarted) {
	    alert("No game is currently running.");
	    return;
	  }
	
	  // ask for confirmation before ending
	  const reallyEnd = confirm(
	    "Are you sure you want to end the game now? This cannot be undone."
	  );
	  if (!reallyEnd) return;
	
	  endGame();
	}
 
 endGameBtn.addEventListener("click", endGameEarly);

	/**
	 * Returns the array of commands after applying Child-Safe and category filters
	 */
	function getFilteredCommands() {
	const childSafeOn = document.getElementById("childSafeMode").checked;
	const category   = document.getElementById("categoryFilter").value;

	// start from full pool
	let pool = commands.slice();

	// 1) Child-Safe filter
	if (childSafeOn) {
		pool = pool.filter(cmd => cmd.childsafe);
	}

	// 2) Category filter
	if (category) {
		pool = pool.filter(cmd => cmd.category === category);
	}

	return pool;
	}

endGameBtn.addEventListener("click", endGameEarly);

function isValidCheckoutScore(score) {
  const excluded = new Set([159, 162, 163, 165, 166, 168, 169]);

  const twoDartExtras = new Set([100, 101, 104, 107, 110]);
  const threeDartExtras = new Set([
    99, 102, 103, 105, 106, 108, 109
  ]);

  if (score >= 41 && score <= 98) return true;          // Two-dart range
  if (twoDartExtras.has(score)) return true;            // Additional two-dart finishes
  if (threeDartExtras.has(score)) return true;          // Extra three-dart finishes
  if (score >= 111 && score <= 170 && !excluded.has(score)) return true;

  return false;
}

function renderScoringButtons(challengeText) {
  const scoreInput = document.getElementById("scoreInput");
  const buttonsArea = document.getElementById("scoreButtonsArea");

  buttonsArea.innerHTML = ""; // Clear old buttons

  const text = challengeText.toLowerCase();
  const match = challengeText.match(/\d+/);
  const base = match ? parseInt(match[0], 10) : null;
  let scores = [];

   // ğŸ¯ Detect if this is a Checkout challenge
  const isCheckout = text.includes("checkout");

  if (isCheckout && base !== null) {
	  if (!isValidCheckoutScore(base)) {
      console.warn(`Invalid checkout score: ${base} is not permitted`);
      scoreInput.style.display = "inline-block";
      buttonsArea.style.display = "none";
      submitScoreBtn.style.display = "inline-block";
      return;
    }

    // âœ… Show single button
    scoreInput.style.display = "none";
    buttonsArea.style.display = "block";
    submitScoreBtn.style.display = "none";

    const btn = document.createElement("button");
    btn.textContent = base;
	btn.classList.add("dynamic-btn");
    btn.style.margin = "5px";
    btn.onclick = () => {
      scoreInput.value = base;
      submitScore();
    };
    buttonsArea.appendChild(btn);
    return;
  }
  // ğŸ¯ Generate buttons based on challenge type
  if (text.includes("treble") && base >= 1 && base <= 20) {
    scores = [base * 3, base * 6, base * 9];
  } else if (text.includes("double") && base >= 1 && base <= 20) {
    scores = [base * 2, base * 4, base * 6];
  } else if ((text.includes("big") || text.includes("small")) && base >= 1 && base <= 20) {
    scores = [base, base * 2, base * 3];
  } else if (text.includes("any") && base >= 1 && base <= 20) {
    scores = [base, base * 2, base * 3, base * 4, base * 5, base * 6, base * 7, base * 8, base * 9];
  } else if (text.includes("shanghai") && base >= 1 && base <= 20) {
    scores = [base * 6];
  } else if (text.includes("bullseye")) {
    scores = [50, 100, 150];
  } else if (text.includes("25")) {
    scores = [25, 50, 75];
  } else if (text.includes("loop")) {
    scores = [70, 140, 210];
  } else if (text.includes("split")) {
    scores = [44, 88, 132];
  } else if (text.includes("bow")) {
    scores = [42, 67];
  } else if (text.includes("61")) {
    scores = [61];
  } else if (text.includes("101")) {
	scores = [101];
  } else if (text.includes("maths")) {
	scores = [50];
  } else if (text.includes("unconventional")) {
	scores = [26];
  } else {
    // Show manual input only
    scoreInput.style.display = "inline-block";
    buttonsArea.style.display = "none";
	submitScoreBtn.style.display = "inline-block";
    return;
  }

  // Show buttons, hide input
  scoreInput.style.display = "none";
  buttonsArea.style.display = "block";
  submitScoreBtn.style.display = "none";

  scores.forEach(score => {
    const btn = document.createElement("button");
    btn.textContent = score;
	btn.classList.add("dynamic-btn");
    btn.style.margin = "5px";
    btn.onclick = () => {
      scoreInput.value = score;
      submitScore(); // uses your existing function
    };
    buttonsArea.appendChild(btn);
  });
}

	function getMaxPossibleScoreForChallenge(challengeText) {
	  const text = challengeText.toLowerCase();
	  const match = challengeText.match(/\d+/);
	  const base = match ? parseInt(match[0], 10) : null;

	  if (text.includes("treble") && base >= 1 && base <= 20) return base * 9;
	  if (text.includes("double") && base >= 1 && base <= 20) return base * 6;
	  if (text.includes("shanghai") && base >= 1 && base <= 20) return base * 6;
	  if (text.includes("big") || text.includes("small")) return base * 3;
	  if (text.includes("bullseye")) return 150; // 3x 50
	  if (text.includes("25")) return 75;  // 3x 25
	  if (text.includes("loop")) return 210;           // 3x 70
	  if (text.includes("61")) return 61;             // 3x 61
	  if (text.includes("split")) return 132;
	  if (text.includes("bow")) return 67;
	  if (text.includes("any") && base >= 1 && base <= 20) return base * 9;
	  if (text.includes("101")) return 101;
	  if (text.includes("fore")) return 180;
	  if (text.includes("skipping")) return 180;
	  if (text.includes("anything")) return 180;
	  if (text.includes("grouping")) return 180;
	  if (text.includes("maths")) return 50;
	  if (text.includes("unconventional")) return 26;

	  return 0; // Default if unknown
	}

	function showScorePop(amount, isFail = false, type = "", extra = "") {
	const pop = document.getElementById("scorePop");

	// Set custom text per effect
	if (type === "mega-combo") {
		pop.textContent = `MEGA COMBO! +${amount}`;
	} else if (type === "double-trouble") {
		pop.textContent = `DOUBLE BUBBLE BONUS! +${amount}`;
	} else if (type === "joker") {
		pop.textContent = `JOKER! +${amount}`;
	} else if (type === "joker-fail") {
		pop.textContent = `JOKER PENALTY`;
	} else if (type === "hardcore") {
		pop.textContent = `ğŸ’£ BOOM!`;
	} else if (type === "streak") {
		pop.textContent = `STREAK BONUS! +${amount}`;
	} else if (type === "drift-fail") {
		pop.textContent = `PERCENTAGE PENALTY! -${amount}`;
	}
	else {
		// No specific type given â€” fallback to default
		type = isFail ? "fail" : "";
		pop.textContent = isFail ? "FAIL" : `+${amount}`;
	}

	// Apply only relevant classes
	pop.className = `score-pop show ${type}`;

	setTimeout(() => {
		pop.classList.remove("show");
	}, 600);

	setTimeout(() => {
		pop.className = "score-pop"; // full reset
	}, 1200);
}
	
	// Fill and display the end-game modal
	function showEndGameModal(sortedPlayers, winners) {
	  const list = document.getElementById("finalScoreList");
	  list.innerHTML = "";

	  sortedPlayers.forEach(p => {
		const li = document.createElement("li");
		li.textContent = `${p.name}: ${p.score}`;
		list.appendChild(li);
	  });

	  // Show who won
	  const title = document.querySelector("#endGameModal h2");
	  title.textContent = winners.length > 1
		? `Winners: ${winners.join(", ")}`
		: `Winner: ${winners[0]}`;

	  document.getElementById("endGameModal").classList.remove("hidden");
	}

	// Hide modal when â€œCloseâ€ is clicked
	document.getElementById("closeEndGameBtn")
	  .addEventListener("click", () => {
		document.getElementById("endGameModal").classList.add("hidden");
		updateScoreboard();  // refresh your UI if needed
	  });

	// Initial load from Firebase
	loadPlayersFromFirebase();
	loadCommandsFromFirebase().then(() => {
	populateCategoryDropdown(); // fills filter dropdown
	renderCommands();           // shows filtered challenge list
		});
	loadHistoryFromFirebase();
	
	// Apply dark mode from localStorage on load
		const darkPref = localStorage.getItem("darkModeEnabled");
		if (darkPref === "true") {
		document.body.classList.add("dark-mode");
		}

	// Ensure correct button state on load
	updateStartButtonState();

</script>
	<!-- Flash overlay for turn transitions -->
	<div id="turnFlashOverlay" class="turn-flash" style="display: none;"></div>
 	<!-- Score Pop -->
	<div id="scorePop" class="score-pop"></div>
</body>
</html>
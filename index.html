<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multiplayer Challenge Game</title>
<style>
  /* Basic light/dark styles */
  body {
    font-family: Arial, sans-serif;
    margin: 1rem;
    background: #f0f0f0;
    color: #222;
  }
  body.dark {
    background: #121212;
    color: #eee;
  }
  button {
    margin: 0.2rem;
    padding: 0.4rem 0.8rem;
    cursor: pointer;
  }
  input[type="text"], input[type="number"] {
    padding: 0.4rem;
    margin: 0.2rem 0;
    font-size: 1rem;
    width: 100%;
    box-sizing: border-box;
  }
  .player-btn.selected {
    background: #007bff;
    color: white;
  }
  #scoreboard li {
    margin: 0.3rem 0;
  }
  #scoreboard li.current {
    font-weight: bold;
    color: #0044cc;
  }
  .commandBox {
    border: 1px solid #ccc;
    padding: 0.5rem;
    margin-bottom: 0.3rem;
    border-radius: 4px;
  }
  .commandBox.current {
    font-weight: bold;
    font-size: 1.3em;
  }
  .commandBox.hardcore {
    color: #b22222;
  }
  .hidden {
    display: none;
  }
  #hardcoreToggleContainer {
    margin-top: 0.5rem;
  }
  #gameControls {
    margin-top: 1rem;
  }
  #startGameBtn {
    margin-top: 1rem;
  }
  .edit-player, .delete-player {
    margin-left: 5px;
    font-size: 0.8rem;
  }
  #darkModeToggle {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 0.5rem 1rem;
  }
  /* Popup overlay styles */
  #endGamePopup {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-size: 1.2rem;
    z-index: 1000;
    visibility: hidden;
  }
  #endGamePopup.visible {
    visibility: visible;
  }
  #endGamePopupContent {
    background: #222;
    padding: 1rem 2rem;
    border-radius: 8px;
    max-width: 400px;
    width: 90%;
  }
  #endGamePopup button {
    margin-top: 1rem;
    background: #007bff;
    border: none;
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    cursor: pointer;
  }
</style>
</head>
<body>

<button id="darkModeToggle" aria-pressed="false">Toggle Dark Mode</button>

<h1>Multiplayer Challenge Game</h1>

<!-- Players Section -->
<section id="playersSection" aria-label="Players Section">
  <h2>Players</h2>
  <input id="newPlayerName" type="text" placeholder="New player name" aria-label="New player name" />
  <button id="addPlayerBtn">Add Player</button>
  <div id="playerButtons" role="list" aria-live="polite" aria-atomic="true"></div>
</section>

<!-- Challenges Section -->
<section id="challengesSection" aria-label="Challenges Section">
  <h2>Challenges</h2>
  <input id="newCommandText" type="text" placeholder="New challenge text" aria-label="New challenge text" />
  <input id="newCommandDesc" type="text" placeholder="Challenge description (optional)" aria-label="Challenge description" />
  <label><input type="checkbox" id="newCommandHardcore" /> Supports Hardcore Mode</label>
  <button id="addCommandBtn">Add Challenge</button>
  <button id="toggleCommandList">Show Challenge List</button>
  <div id="commandList" class="hidden" aria-live="polite" aria-atomic="true"></div>
</section>

<!-- Game Setup Controls -->
<section id="setupSection" aria-label="Game Setup">
  <h2>Game Setup</h2>
  <label for="numRounds">Number of Rounds:</label>
  <input id="numRounds" type="number" min="1" value="10" aria-label="Number of rounds to play" />
  <label for="startingScore">Starting Score:</label>
  <input id="startingScore" type="number" min="0" value="0" aria-label="Starting score for all players" />
  <label><input type="checkbox" id="hardcoreToggleBeforeStart" /> Hardcore Mode (Fail resets score to zero)</label>
</section>

<!-- Game Area -->
<section id="gameArea" aria-live="polite" aria-atomic="true" class="hidden">
  <h2>Current Challenge</h2>
  <div id="currentChallenge" class="commandBox"></div>
  <div id="challengeDescription" style="font-style: italic; margin-bottom: 0.5rem;"></div>

  <!-- Hardcore toggle during game, visible only if challenge supports it -->
  <div id="hardcoreToggleContainer" class="hidden">
    <label>
      <input type="checkbox" id="hardcoreToggleDuringGame" />
      Hardcore Mode for this challenge (Fail resets to zero)
    </label>
  </div>

  <div id="gameControls">
    <input id="scoreInput" type="number" min="0" placeholder="Enter score for player" aria-label="Score input" />
    <button id="submitScoreBtn">Submit Score</button>
    <button id="failChallengeBtn">Fail Challenge</button>
    <button id="undoScoreBtn">Undo Last Score</button>
  </div>

  <!-- Start Game button at the bottom -->
  <button id="startGameBtn">Start Game</button>
</section>

<!-- Scoreboard -->
<section id="scoreboard" aria-label="Scoreboard" aria-live="polite" aria-atomic="true">
  <h2>Scoreboard</h2>
  <ul id="scoreList"></ul>
</section>

<!-- End Game Popup -->
<div id="endGamePopup" role="dialog" aria-modal="true" aria-labelledby="endGameTitle" class="">
  <div id="endGamePopupContent">
    <h2 id="endGameTitle">Game Over!</h2>
    <div id="finalScores"></div>
    <button id="closeEndGameBtn">Close</button>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
<script>
  // Firebase config - REPLACE with your actual config
  const firebaseConfig = {
    apiKey: "AIzaSyAusKA2YiJTelSm54EJfRbVJMk0M6mh_WM",
    authDomain: "denchfield-half-it.firebaseapp.com",
    projectId: "denchfield-half-it",
    storageBucket: "denchfield-half-it.firebasestorage.app",
    messagingSenderId: "494344468882",
    appId: "1:494344468882:web:7a1f0d2ac938627206e94b",
    measurementId: "G-ZQQM5PNWPV"
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // ===========================
  // Game state variables
  // ===========================
  let players = []; // {id, name}
  let selectedPlayerId = null;
  let commands = []; // {id, text, description, hardcore}
  let rounds = 10;
  let startingScore = 0;

  let currentRound = 0;
  let currentPlayerIndex = 0;
  let scores = {}; // playerId => score
  let history = []; // {playerId, round, commandIndex, score, hardcore, success}

  // UI Elements references
  const playerButtonsDiv = document.getElementById("playerButtons");
  const commandListDiv = document.getElementById("commandList");
  const currentChallengeDiv = document.getElementById("currentChallenge");
  const challengeDescriptionDiv = document.getElementById("challengeDescription");
  const scoreInput = document.getElementById("scoreInput");
  const submitScoreBtn = document.getElementById("submitScoreBtn");
  const failChallengeBtn = document.getElementById("failChallengeBtn");
  const undoScoreBtn = document.getElementById("undoScoreBtn");
  const scoreListUl = document.getElementById("scoreList");
  const startGameBtn = document.getElementById("startGameBtn");
  const numRoundsInput = document.getElementById("numRounds");
  const startingScoreInput = document.getElementById("startingScore");
  const hardcoreToggleBeforeStart = document.getElementById("hardcoreToggleBeforeStart");
  const hardcoreToggleContainer = document.getElementById("hardcoreToggleContainer");
  const hardcoreToggleDuringGame = document.getElementById("hardcoreToggleDuringGame");
  const newPlayerNameInput = document.getElementById("newPlayerName");
  const addPlayerBtn = document.getElementById("addPlayerBtn");
  const newCommandTextInput = document.getElementById("newCommandText");
  const newCommandDescInput = document.getElementById("newCommandDesc");
  const newCommandHardcoreCheckbox = document.getElementById("newCommandHardcore");
  const addCommandBtn = document.getElementById("addCommandBtn");
  const toggleCommandListBtn = document.getElementById("toggleCommandList");
  const gameAreaSection = document.getElementById("gameArea");
  const playersSection = document.getElementById("playersSection");
  const challengesSection = document.getElementById("challengesSection");
  const setupSection = document.getElementById("setupSection");
  const endGamePopup = document.getElementById("endGamePopup");
  const finalScoresDiv = document.getElementById("finalScores");
  const closeEndGameBtn = document.getElementById("closeEndGameBtn");
  const darkModeToggle = document.getElementById("darkModeToggle");

  // ===========================
  // Helper Functions
  // ===========================

  // Save players array to Firestore
  async function savePlayersToFirestore() {
    try {
      await db.collection("players").doc("playersList").set({ players });
    } catch (error) {
      console.error("Error saving players to Firestore:", error);
    }
  }

  // Load players from Firestore, or fallback to empty
  async function loadPlayersFromFirestore() {
    try {
      const doc = await db.collection("players").doc("playersList").get();
      if (doc.exists) {
        players = doc.data().players || [];
      } else {
        players = [];
      }
      renderPlayers();
    } catch (error) {
      console.error("Error loading players from Firestore:", error);
      players = [];
      renderPlayers();
    }
  }

  // Save commands array to Firestore
  async function saveCommandsToFirestore() {
    try {
      await db.collection("commands").doc("commandsList").set({ commands });
    } catch (error) {
      console.error("Error saving commands to Firestore:", error);
    }
  }

  // Load commands from Firestore, or fallback with a default set if empty
  async function loadCommandsFromFirestore() {
    try {
      const doc = await db.collection("commands").doc("commandsList").get();
      if (doc.exists) {
        commands = doc.data().commands || [];
      } else {
        commands = [];
      }
      if (commands.length === 0) {
        // Default commands sample
        commands = [
          { id: generateId(), text: "Sing a song", description: "Perform a song of your choice", hardcore: false },
          { id: generateId(), text: "Do 10 push-ups", description: "Physical challenge", hardcore: true },
          { id: generateId(), text: "Tell a joke", description: "Make everyone laugh", hardcore: false },
        ];
        await saveCommandsToFirestore();
      }
      renderCommands();
    } catch (error) {
      console.error("Error loading commands from Firestore:", error);
      commands = [];
      renderCommands();
    }
  }

  // Generate unique ID for players and commands
  function generateId() {
    return '_' + Math.random().toString(36).substr(2, 9);
  }

  // Render players as buttons
  function renderPlayers() {
    playerButtonsDiv.innerHTML = "";
    players.forEach(player => {
      const btn = document.createElement("button");
      btn.textContent = player.name;
      btn.className = "player-btn";
      btn.setAttribute("role", "listitem");
      btn.dataset.id = player.id;
      btn.title = `Select ${player.name}`;
      if (player.id === selectedPlayerId) {
        btn.classList.add("selected");
      }
      btn.addEventListener("click", () => {
        selectPlayer(player.id);
      });
      playerButtonsDiv.appendChild(btn);
    });
  }

  // Select player by ID
  function selectPlayer(id) {
    if (players.find(p => p.id === id)) {
      selectedPlayerId = id;
      renderPlayers();
      updateScoreboard();
    }
  }

  // Render commands in list (with edit and delete)
  function renderCommands() {
    commandListDiv.innerHTML = "";
    if (commands.length === 0) {
      commandListDiv.textContent = "No challenges available.";
      return;
    }
    commands.forEach((cmd, index) => {
      const div = document.createElement("div");
      div.className = "commandBox";
      div.textContent = cmd.text + (cmd.hardcore ? " [Hardcore]" : "");
      if (cmd.description) {
        const descSpan = document.createElement("span");
        descSpan.style.fontStyle = "italic";
        descSpan.style.marginLeft = "0.5rem";
        descSpan.textContent = `(${cmd.description})`;
        div.appendChild(descSpan);
      }
      // Edit and Delete buttons
      const editBtn = document.createElement("button");
      editBtn.textContent = "Edit";
      editBtn.className = "edit-player";
      editBtn.addEventListener("click", () => {
        editCommand(index);
      });
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.className = "delete-player";
      deleteBtn.addEventListener("click", () => {
        deleteCommand(index);
      });
      div.appendChild(editBtn);
      div.appendChild(deleteBtn);
      commandListDiv.appendChild(div);
    });
  }

  // Edit command
  function editCommand(index) {
    const cmd = commands[index];
    const newText = prompt("Edit challenge text:", cmd.text);
    if (newText === null) return; // cancel
    const newDesc = prompt("Edit description (optional):", cmd.description || "");
    const newHardcore = confirm("Should this challenge support hardcore mode? OK = yes, Cancel = no");
    commands[index] = {
      ...cmd,
      text: newText.trim() || cmd.text,
      description: newDesc.trim() || "",
      hardcore: newHardcore
    };
    saveCommandsToFirestore();
    renderCommands();
  }

  // Delete command
  function deleteCommand(index) {
    if (confirm("Delete this challenge?")) {
      commands.splice(index, 1);
      saveCommandsToFirestore();
      renderCommands();
    }
  }

  // Add new player
  addPlayerBtn.addEventListener("click", () => {
    const name = newPlayerNameInput.value.trim();
    if (!name) {
      alert("Player name cannot be empty.");
      return;
    }
    if (players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
      alert("Player with this name already exists.");
      return;
    }
    players.push({ id: generateId(), name });
    savePlayersToFirestore();
    renderPlayers();
    newPlayerNameInput.value = "";
  });

  // Add new command
  addCommandBtn.addEventListener("click", () => {
    const text = newCommandTextInput.value.trim();
    if (!text) {
      alert("Challenge text cannot be empty.");
      return;
    }
    const desc = newCommandDescInput.value.trim();
    const hardcore = newCommandHardcoreCheckbox.checked;
    commands.push({ id: generateId(), text, description: desc, hardcore });
    saveCommandsToFirestore();
    renderCommands();
    newCommandTextInput.value = "";
    newCommandDescInput.value = "";
    newCommandHardcoreCheckbox.checked = false;
  });

  // Toggle command list visibility
  toggleCommandListBtn.addEventListener("click", () => {
    if (commandListDiv.classList.contains("hidden")) {
      commandListDiv.classList.remove("hidden");
      toggleCommandListBtn.textContent = "Hide Challenge List";
    } else {
      commandListDiv.classList.add("hidden");
      toggleCommandListBtn.textContent = "Show Challenge List";
    }
  });

  // Update scoreboard display
  function updateScoreboard() {
    scoreListUl.innerHTML = "";
    players.forEach(player => {
      const li = document.createElement("li");
      li.textContent = `${player.name}: ${scores[player.id] ?? startingScore}`;
      if (player.id === selectedPlayerId) {
        li.classList.add("current");
      }
      scoreListUl.appendChild(li);
    });
  }

  // Start game button event
  startGameBtn.addEventListener("click", () => {
    if (players.length === 0) {
      alert("Please add at least one player.");
      return;
    }
    rounds = parseInt(numRoundsInput.value, 10);
    if (isNaN(rounds) || rounds < 1) {
      alert("Please enter a valid number of rounds.");
      return;
    }
    startingScore = parseInt(startingScoreInput.value, 10);
    if (isNaN(startingScore) || startingScore < 0) {
      alert("Please enter a valid starting score.");
      return;
    }
    if (commands.length === 0) {
      alert("Please add at least one challenge.");
      return;
    }
    // Reset game state
    currentRound = 1;
    currentPlayerIndex = 0;
    history = [];
    scores = {};
    players.forEach(p => scores[p.id] = startingScore);
    selectedPlayerId = players[0].id;
    renderPlayers();
    updateScoreboard();

    // Show game area and hide setup/player/challenge setup
    gameAreaSection.classList.remove("hidden");
    playersSection.classList.add("hidden");
    challengesSection.classList.add("hidden");
    setupSection.classList.add("hidden");
    startGameBtn.disabled = true;

    loadNextChallenge();
  });

  // Load next challenge for current player and round
  function loadNextChallenge() {
    if (currentRound > rounds) {
      endGame();
      return;
    }
    selectedPlayerId = players[currentPlayerIndex].id;
    renderPlayers();
    updateScoreboard();

    // Select random challenge for this round
    const challengeIndex = Math.floor(Math.random() * commands.length);
    currentChallengeDiv.textContent = commands[challengeIndex].text;
    challengeDescriptionDiv.textContent = commands[challengeIndex].description || "";
    currentChallengeDiv.className = "commandBox";
    if (commands[challengeIndex].hardcore) {
      currentChallengeDiv.classList.add("hardcore");
    }

    // Show or hide hardcore toggle during game based on challenge support
    if (commands[challengeIndex].hardcore) {
      hardcoreToggleContainer.classList.remove("hidden");
      // Set toggle value: if overall hardcoreBeforeStart is enabled, default toggle on, else off
      hardcoreToggleDuringGame.checked = hardcoreToggleBeforeStart.checked;
    } else {
      hardcoreToggleContainer.classList.add("hidden");
      hardcoreToggleDuringGame.checked = false;
    }

    // Store current challenge index for scoring
    currentChallengeIndex = challengeIndex;

    // Reset score input and focus
    scoreInput.value = "";
    scoreInput.focus();

    // Enable buttons
    submitScoreBtn.disabled = false;
    failChallengeBtn.disabled = false;
    undoScoreBtn.disabled = history.length === 0;
  }

  // Submit score button handler
  submitScoreBtn.addEventListener("click", () => {
    if (!selectedPlayerId) {
      alert("Please select a player.");
      return;
    }
    let inputScore = parseInt(scoreInput.value, 10);
    if (isNaN(inputScore) || inputScore < 0) {
      alert("Please enter a valid non-negative score.");
      return;
    }

    // Handle hardcore fail (score input implies success here)
    handleScoreSubmission(inputScore, true);
  });

  // Fail challenge button handler
  failChallengeBtn.addEventListener("click", () => {
    if (!selectedPlayerId) {
      alert("Please select a player.");
      return;
    }
    // Fail = no score, but if hardcore mode active, reset score to zero
    handleScoreSubmission(0, false);
  });

  // Undo last score button handler
  undoScoreBtn.addEventListener("click", () => {
    if (history.length === 0) return;

    // Undo last entry
    const last = history.pop();
    scores[last.playerId] = last.previousScore ?? startingScore;
    currentRound = last.round;
    currentPlayerIndex = players.findIndex(p => p.id === last.playerId);

    updateScoreboard();
    renderPlayers();

    // Reload last challenge for this player/round
    currentChallengeDiv.textContent = commands[last.commandIndex].text;
    challengeDescriptionDiv.textContent = commands[last.commandIndex].description || "";
    currentChallengeDiv.className = "commandBox";
    if (commands[last.commandIndex].hardcore) {
      currentChallengeDiv.classList.add("hardcore");
      hardcoreToggleContainer.classList.remove("hidden");
      hardcoreToggleDuringGame.checked = last.hardcore;
    } else {
      hardcoreToggleContainer.classList.add("hidden");
      hardcoreToggleDuringGame.checked = false;
    }

    scoreInput.value = last.score;
    scoreInput.focus();

    // Enable buttons
    submitScoreBtn.disabled = false;
    failChallengeBtn.disabled = false;
    undoScoreBtn.disabled = history.length === 0;
  });

  // Handle submission of score or fail
  function handleScoreSubmission(scoreValue, success) {
    const playerId = selectedPlayerId;
    const currentScore = scores[playerId] ?? startingScore;
    const isHardcoreThisChallenge = hardcoreToggleDuringGame.checked;

    // Save previous score to allow undo
    const previousScore = currentScore;

    // Update score with hardcore logic
    let newScore;
    if (success) {
      newScore = currentScore + scoreValue;
    } else {
      if (isHardcoreThisChallenge) {
        newScore = 0; // reset score on fail
      } else {
        newScore = currentScore;
      }
    }
    scores[playerId] = newScore;

    // Save to history for undo
    history.push({
      playerId,
      round: currentRound,
      commandIndex: currentChallengeIndex,
      score: scoreValue,
      hardcore: isHardcoreThisChallenge,
      success,
      previousScore,
    });

    // Move to next player/round
    currentPlayerIndex++;
    if (currentPlayerIndex >= players.length) {
      currentPlayerIndex = 0;
      currentRound++;
    }

    updateScoreboard();
    renderPlayers();

    // Clear inputs
    scoreInput.value = "";
    hardcoreToggleDuringGame.checked = false;

    // Disable undo if no history
    undoScoreBtn.disabled = false;

    loadNextChallenge();
  }

  // End game: show popup with final results
  function endGame() {
    // Build final score list
    finalScoresDiv.innerHTML = "";
    const ul = document.createElement("ul");
    players.forEach(p => {
      const li = document.createElement("li");
      li.textContent = `${p.name}: ${scores[p.id] ?? startingScore}`;
      ul.appendChild(li);
    });
    finalScoresDiv.appendChild(ul);

    // Show popup
    endGamePopup.classList.add("visible");
    endGamePopup.focus();

    // Reset UI
    startGameBtn.disabled = false;
    gameAreaSection.classList.add("hidden");
    playersSection.classList.remove("hidden");
    challengesSection.classList.remove("hidden");
    setupSection.classList.remove("hidden");
  }

  closeEndGameBtn.addEventListener("click", () => {
    endGamePopup.classList.remove("visible");
  });

  // Dark mode toggle
  darkModeToggle.addEventListener("click", () => {
    document.body.classList.toggle("dark");
    const pressed = document.body.classList.contains("dark");
    darkModeToggle.setAttribute("aria-pressed", pressed);
  });

  // Load initial data on startup
  async function initializeApp() {
    await loadPlayersFromFirestore();
    await loadCommandsFromFirestore();

    // Set default selected player if any
    if (players.length > 0) {
      selectedPlayerId = players[0].id;
      renderPlayers();
    }
  }

  initializeApp();
</script>

</body>
</html>

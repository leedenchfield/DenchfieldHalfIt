<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Denchfield Half-It Challenge!</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: auto;
      background-color: white;
      color: black;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark-mode {
      background-color: #111;
      color: #eee;
    }
    input, button, select, textarea {
      font-size: 1em;
      padding: 8px;
      margin: 5px 0;
      width: 100%;
    }
    #commandList, #gameArea, #historyArea, #playerButtons {
      margin-top: 20px;
    }
    .hidden {
      display: none;
    }
    .commandBox {
      font-size: 2em;
      margin: 15px 0;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 5px;
      font-weight: bold;
    }
    .descriptionBox {
      font-size: 0.9em;
      margin: 10px 0;
      font-style: italic;
    }
    .score {
      font-size: 1.4em;
      margin: 10px 0;
    }
    #scoreboard {
      background: #eef;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
    }
    #scoreboard ul {
      padding-left: 20px;
    }
    .player-btn {
      margin: 5px;
      padding: 5px 10px;
      cursor: pointer;
      background-color: #ccc;
      border: none;
      border-radius: 4px;
      transition: 0.3s ease;
    }
    .player-btn.selected {
      background-color: #0044cc;
      color: white;
      font-weight: bold;
      box-shadow: 0 0 5px #0044cc;
    }
    .hardcore {
      color: red;
      font-weight: bold;
    }
    .edit-btn, .delete-btn {
      float: right;
      font-size: 0.8em;
      padding: 2px 6px;
      margin-left: 5px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    .edit-btn {
      background-color: #faa;
    }
    .delete-btn {
      background-color: #fcc;
    }
    #toggleCommandList {
      margin-top: 10px;
      cursor: pointer;
      background: #ddd;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
    }
    #darkModeToggle {
      margin: 10px 0;
      padding: 5px 10px;
      background-color: #444;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #hardcoreOverrideContainer {
      margin-top: 10px;
      font-weight: bold;
      color: red;
    }
    #gameOverPopup {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #gameOverPopupContent {
      background: white;
      padding: 20px;
      border-radius: 10px;
      max-width: 400px;
      width: 90%;
    }
  </style>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
</head>
<body>
  <button id="darkModeToggle">Toggle Dark Mode</button>

  <div id="playerSection">
    <h2>Players</h2>
    <div id="playerButtons"></div>
    <input id="newPlayerName" placeholder="Add new player" />
    <button id="addPlayerBtn">Add Player</button>
  </div>

  <button id="toggleCommandList">Toggle Challenge List</button>
  <div id="commandList"></div>
  <div>
    <input id="newCommandText" placeholder="New challenge text" />
    <input id="newCommandDesc" placeholder="Optional description" />
    <label><input type="checkbox" id="newCommandHardcore" /> Hardcore Challenge</label>
    <button id="addCommandBtn">Add Challenge</button>
  </div>

  <div>
    <label>
      <input type="checkbox" id="globalHardcoreToggle" /> Enable Global Hardcore Mode (one random challenge per game)
    </label>
  </div>

  <div>
    <label>
      Number of challenges per round:
      <input type="number" id="numChallengesInput" min="1" max="50" value="5" />
    </label>
  </div>

  <button id="startGameBtn">Start Game</button>

  <div id="gameArea" class="hidden">
    <div id="currentPlayerName" style="font-weight:bold; font-size:1.3em;"></div>
    <div id="currentChallenge" class="commandBox"></div>
    <div id="challengeDescription" class="descriptionBox"></div>

    <div id="hardcoreOverrideContainer" class="hidden">
      <label>
        <input type="checkbox" id="challengeHardcoreOverride" />
        Play this challenge as Hardcore
      </label>
    </div>

    <input type="number" id="scoreInput" min="0" placeholder="Enter score for challenge" />
    <button id="scoreBtn">Submit Score</button>
    <button id="failBtn">Fail Challenge</button>
    <button id="undoBtn">Undo Last Action</button>
  </div>

  <div id="scoreboard" class="hidden">
    <h3>Scoreboard</h3>
    <ul id="scoreList"></ul>
  </div>

  <div id="historyArea" class="hidden">
    <h3>Game History</h3>
    <ul id="historyList"></ul>
  </div>

  <div id="gameOverPopup">
    <div id="gameOverPopupContent">
      <h2>Game Over!</h2>
      <div id="finalResults"></div>
      <button id="closePopupBtn">Close</button>
    </div>
  </div>

<script>
  // Firebase config - replace with your own config
  const firebaseConfig = {
    apiKey: "AIzaSyAusKA2YiJTelSm54EJfRbVJMk0M6mh_WM",
    authDomain: "denchfield-half-it.firebaseapp.com",
    projectId: "denchfield-half-it",
    storageBucket: "denchfield-half-it.firebasestorage.app",
    messagingSenderId: "494344468882",
    appId: "1:494344468882:web:7a1f0d2ac938627206e94b",
    measurementId: "G-ZQQM5PNWPV"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // DOM elements
  const playerButtonsDiv = document.getElementById("playerButtons");
  const commandListDiv = document.getElementById("commandList");
  const scoreList = document.getElementById("scoreList");
  const historyList = document.getElementById("historyList");
  const currentPlayerNameDiv = document.getElementById("currentPlayerName");
  const currentChallengeDiv = document.getElementById("currentChallenge");
  const challengeDescriptionDiv = document.getElementById("challengeDescription");
  const challengeHardcoreOverrideCheckbox = document.getElementById("challengeHardcoreOverride");
  const hardcoreOverrideContainer = document.getElementById("hardcoreOverrideContainer");
  const scoreInput = document.getElementById("scoreInput");
  const newPlayerNameInput = document.getElementById("newPlayerName");
  const addPlayerBtn = document.getElementById("addPlayerBtn");
  const newCommandTextInput = document.getElementById("newCommandText");
  const newCommandDescInput = document.getElementById("newCommandDesc");
  const newCommandHardcoreCheckbox = document.getElementById("newCommandHardcore");
  const addCommandBtn = document.getElementById("addCommandBtn");
  const toggleCommandListBtn = document.getElementById("toggleCommandList");
  const darkModeToggleBtn = document.getElementById("darkModeToggle");
  const globalHardcoreToggle = document.getElementById("globalHardcoreToggle");
  const numChallengesInput = document.getElementById("numChallengesInput");
  const startGameBtn = document.getElementById("startGameBtn");
  const gameArea = document.getElementById("gameArea");
  const scoreboard = document.getElementById("scoreboard");
  const historyArea = document.getElementById("historyArea");
  const scoreBtn = document.getElementById("scoreBtn");
  const failBtn = document.getElementById("failBtn");
  const undoBtn = document.getElementById("undoBtn");
  const gameOverPopup = document.getElementById("gameOverPopup");
  const finalResultsDiv = document.getElementById("finalResults");
  const closePopupBtn = document.getElementById("closePopupBtn");

  // State variables
  let players = [];
  let commands = [];
  let selectedPlayers = new Set();
  let gameInProgress = false;
  let currentRound = 1;
  let challengesPerRound = 5; // default
  let currentChallengeIndex = 0; // index for challenges array, shared for all players
  let currentPlayerTurnIndex = 0; // player turn within the round/challenge
  let currentRoundChallenges = []; // array of challenge indexes for the round
  let hardcoreChallengeIndex = null; // index of the challenge selected as global hardcore challenge
  let hardcoreOverrideActive = false; // override toggle for hardcore on current challenge

  let history = [];
  let undoStack = [];

  // Utility
  function randomInt(max) {
    return Math.floor(Math.random() * max);
  }

  // Load players from Firestore
  async function loadPlayers() {
    players = [];
    selectedPlayers.clear();
    playerButtonsDiv.innerHTML = "";
    const snapshot = await db.collection("players").get();
    snapshot.forEach(doc => {
      const data = doc.data();
      players.push({ id: doc.id, name: data.name, score: 0 });
    });
    renderPlayerButtons();
  }

  function renderPlayerButtons() {
    playerButtonsDiv.innerHTML = "";
    players.forEach(player => {
      const btn = document.createElement("button");
      btn.textContent = player.name;
      btn.className = "player-btn";
      btn.onclick = () => {
        if (gameInProgress) return; // disable selection during game
        if (selectedPlayers.has(player.id)) {
          selectedPlayers.delete(player.id);
          btn.classList.remove("selected");
        } else {
          selectedPlayers.add(player.id);
          btn.classList.add("selected");
        }
      };
      playerButtonsDiv.appendChild(btn);
    });
  }

  addPlayerBtn.onclick = async () => {
    const name = newPlayerNameInput.value.trim();
    if (!name) return alert("Player name cannot be empty");
    await db.collection("players").add({ name });
    newPlayerNameInput.value = "";
    await loadPlayers();
  };

  // Load commands from Firestore
  async function loadCommands() {
    commands = [];
    commandListDiv.innerHTML = "";
    const snapshot = await db.collection("commands").get();
    snapshot.forEach(doc => {
      const data = doc.data();
      commands.push({
        id: doc.id,
        text: data.text,
        description: data.description || "",
        hardcore: data.hardcore || false,
      });
    });
    renderCommandList();
  }

  function renderCommandList() {
    commandListDiv.innerHTML = "";
    commands.forEach(cmd => {
      const div = document.createElement("div");
      div.innerHTML = `<strong>${cmd.text}</strong><br/><em>${cmd.description}</em>` + (cmd.hardcore ? " <span class='hardcore'>(Hardcore)</span>" : "");
      const editBtn = document.createElement("button");
      editBtn.textContent = "Edit";
      editBtn.className = "edit-btn";
      editBtn.onclick = () => editCommand(cmd);
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.className = "delete-btn";
      deleteBtn.onclick = () => deleteCommand(cmd.id);
      div.appendChild(editBtn);
      div.appendChild(deleteBtn);
      commandListDiv.appendChild(div);
    });
  }

  addCommandBtn.onclick = async () => {
    const text = newCommandTextInput.value.trim();
    const description = newCommandDescInput.value.trim();
    const hardcore = newCommandHardcoreCheckbox.checked;
    if (!text) return alert("Challenge text cannot be empty");
    await db.collection("commands").add({ text, description, hardcore });
    newCommandTextInput.value = "";
    newCommandDescInput.value = "";
    newCommandHardcoreCheckbox.checked = false;
    await loadCommands();
  };

  function editCommand(cmd) {
    const newText = prompt("Edit challenge text:", cmd.text);
    if (newText === null) return;
    const newDesc = prompt("Edit description:", cmd.description);
    if (newDesc === null) return;
    const newHardcore = confirm("Make this a hardcore challenge?");
    db.collection("commands").doc(cmd.id).set({
      text: newText.trim(),
      description: newDesc.trim(),
      hardcore: newHardcore
    });
    loadCommands();
  }

  function deleteCommand(id) {
    if (confirm("Delete this challenge?")) {
      db.collection("commands").doc(id).delete().then(loadCommands);
    }
  }

  // Toggle challenge list visibility
  toggleCommandListBtn.onclick = () => {
    commandListDiv.classList.toggle("hidden");
  };

  // Dark mode toggle
  darkModeToggleBtn.onclick = () => {
    document.body.classList.toggle("dark-mode");
  };

  // Scoreboard update
  function updateScoreboard() {
    scoreList.innerHTML = "";
    players.forEach(p => {
      const li = document.createElement("li");
      li.textContent = `${p.name}: ${p.score}`;
      scoreList.appendChild(li);
    });
  }

  // History update
  function addHistoryEntry(entry) {
    history.push(entry);
    const li = document.createElement("li");
    li.textContent = entry;
    historyList.appendChild(li);
  }

  // Pick a random challenge index excluding the final challenge for hardcore
  function pickHardcoreChallengeIndex() {
    if (challengesPerRound <= 1) return null; // Can't have hardcore if only 1 challenge
    const maxIndex = challengesPerRound - 2; // exclude last challenge
    return randomInt(maxIndex + 1);
  }

  // Setup new game
  function startGame() {
    if (selectedPlayers.size === 0) {
      alert("Select at least one player to start.");
      return;
    }
    if (commands.length === 0) {
      alert("No challenges available.");
      return;
    }
    challengesPerRound = parseInt(numChallengesInput.value);
    if (isNaN(challengesPerRound) || challengesPerRound < 1) {
      alert("Invalid number of challenges.");
      return;
    }
    if (challengesPerRound > commands.length) {
      alert("Not enough challenges for the number selected.");
      return;
    }

    // Reset
    gameInProgress = true;
    currentRound = 1;
    currentChallengeIndex = 0;
    currentPlayerTurnIndex = 0;
    history = [];
    undoStack = [];

    // Reset player scores
    players.forEach(p => { p.score = 0; });
    updateScoreboard();
    historyList.innerHTML = "";

    // Filter selected players into a gamePlayers array for turn order
    gamePlayers = players.filter(p => selectedPlayers.has(p.id));

    // Select challenges for the round - random without repeats
    currentRoundChallenges = [];
    let challengeIndexes = [];
    for(let i=0; i<commands.length; i++) challengeIndexes.push(i);
    // shuffle
    for (let i = challengeIndexes.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [challengeIndexes[i], challengeIndexes[j]] = [challengeIndexes[j], challengeIndexes[i]];
    }
    currentRoundChallenges = challengeIndexes.slice(0, challengesPerRound);

    // Determine global hardcore challenge index if enabled
    if(globalHardcoreToggle.checked) {
      hardcoreChallengeIndex = pickHardcoreChallengeIndex();
    } else {
      hardcoreChallengeIndex = null;
    }

    hardcoreOverrideActive = false;

    // UI show game area
    gameArea.classList.remove("hidden");
    scoreboard.classList.remove("hidden");
    historyArea.classList.remove("hidden");

    // Disable player selection and adding during game
    disablePlayerControls(true);

    updateUIForTurn();
  }

  function disablePlayerControls(disable) {
    addPlayerBtn.disabled = disable;
    newPlayerNameInput.disabled = disable;
    addCommandBtn.disabled = disable;
    newCommandTextInput.disabled = disable;
    newCommandDescInput.disabled = disable;
    newCommandHardcoreCheckbox.disabled = disable;
    toggleCommandListBtn.disabled = disable;
    startGameBtn.disabled = disable;
    numChallengesInput.disabled = disable;
    globalHardcoreToggle.disabled = disable;
    // Also disable toggling player buttons
    playerButtonsDiv.querySelectorAll("button").forEach(btn => btn.disabled = disable);
  }

  // Check if current challenge is the global hardcore challenge
  function isGlobalHardcoreChallenge() {
    return hardcoreChallengeIndex === currentChallengeIndex;
  }

  // Determine if the current challenge is hardcore for scoring (global override and per challenge)
  function currentChallengeIsHardcore() {
    if (isGlobalHardcoreChallenge()) {
      return hardcoreOverrideActive;
    }
    return commands[currentRoundChallenges[currentChallengeIndex]].hardcore;
  }

  // Update UI for current player & challenge
  function updateUIForTurn() {
    if (!gameInProgress) return;

    const player = gamePlayers[currentPlayerTurnIndex];
    const challengeIdx = currentRoundChallenges[currentChallengeIndex];
    const challenge = commands[challengeIdx];

    currentPlayerNameDiv.textContent = `Player: ${player.name}`;
    currentChallengeDiv.textContent = challenge.text;
    challengeDescriptionDiv.textContent = challenge.description;

    // Show hardcore override toggle if this is global hardcore challenge
    if (isGlobalHardcoreChallenge()) {
      hardcoreOverrideContainer.classList.remove("hidden");
      challengeHardcoreOverrideCheckbox.checked = hardcoreOverrideActive;
      challengeHardcoreOverrideCheckbox.disabled = false;
    } else {
      hardcoreOverrideContainer.classList.add("hidden");
      challengeHardcoreOverrideCheckbox.checked = false;
      challengeHardcoreOverrideCheckbox.disabled = true;
    }

    // Reset score input
    scoreInput.value = "";
  }

  // Advance to next player/challenge or end game
  function advanceTurn() {
    currentPlayerTurnIndex++;
    if (currentPlayerTurnIndex >= gamePlayers.length) {
      currentPlayerTurnIndex = 0;
      currentChallengeIndex++;
    }

    if (currentChallengeIndex >= challengesPerRound) {
      // Game over
      endGame();
    } else {
      updateUIForTurn();
    }
  }

  // Handle score submission
  function submitScore() {
    const player = gamePlayers[currentPlayerTurnIndex];
    const challengeIdx = currentRoundChallenges[currentChallengeIndex];
    const challenge = commands[challengeIdx];
    let score = parseInt(scoreInput.value);
    if (isNaN(score) || score < 0) {
      alert("Enter a valid positive score.");
      return;
    }

    // Save history and undo state
    const historyEntry = `${player.name} scored ${score} on challenge "${challenge.text}"${currentChallengeIsHardcore() ? " (Hardcore)" : ""}`;
    addHistoryEntry(historyEntry);
    undoStack.push({
      playerId: player.id,
      previousScore: player.score,
      action: 'score'
    });

    // Add score
    player.score += score;

    updateScoreboard();
    advanceTurn();
  }

  // Handle challenge fail
  function failChallenge() {
    const player = gamePlayers[currentPlayerTurnIndex];
    const challengeIdx = currentRoundChallenges[currentChallengeIndex];
    const challenge = commands[challengeIdx];

    // Save undo info
    undoStack.push({
      playerId: player.id,
      previousScore: player.score,
      action: 'fail'
    });

    let message;

    if (currentChallengeIsHardcore()) {
      // Fail means player score reset to zero for hardcore challenge
      message = `${player.name} failed a HARDCORE challenge and their score is reset!`;
      player.score = 0;
    } else {
      // Fail halves the player's score (round down)
      message = `${player.name} failed the challenge and their score is halved.`;
      player.score = Math.floor(player.score / 2);
    }
    addHistoryEntry(message);
    updateScoreboard();
    advanceTurn();
  }

  // Undo last action
  function undoLastAction() {
    if (undoStack.length === 0) {
      alert("Nothing to undo.");
      return;
    }
    const last = undoStack.pop();

    const player = players.find(p => p.id === last.playerId);
    if (!player) return;

    player.score = last.previousScore;

    // Undo move in turn order (go back one turn)
    if (currentPlayerTurnIndex === 0) {
      currentChallengeIndex--;
      currentPlayerTurnIndex = gamePlayers.length - 1;
    } else {
      currentPlayerTurnIndex--;
    }

    updateScoreboard();
    updateUIForTurn();

    // Remove last history entry
    if (history.length > 0) {
      history.pop();
      if (historyList.lastChild) historyList.removeChild(historyList.lastChild);
    }
  }

  function endGame() {
    gameInProgress = false;
    disablePlayerControls(false);

    // Show final results
    finalResultsDiv.innerHTML = "<ul>" + players
      .filter(p => selectedPlayers.has(p.id))
      .sort((a,b) => b.score - a.score)
      .map(p => `<li>${p.name}: ${p.score}</li>`).join("") + "</ul>";

    gameOverPopup.style.display = "flex";

    gameArea.classList.add("hidden");
  }

  closePopupBtn.onclick = () => {
    gameOverPopup.style.display = "none";
  };

  // Event handlers
  startGameBtn.onclick = startGame;
  scoreBtn.onclick = submitScore;
  failBtn.onclick = failChallenge;
  undoBtn.onclick = undoLastAction;
  challengeHardcoreOverrideCheckbox.onchange = () => {
    hardcoreOverrideActive = challengeHardcoreOverrideCheckbox.checked;
  };

  // Initial load
  loadPlayers();
  loadCommands();
</script>
</body>
</html>

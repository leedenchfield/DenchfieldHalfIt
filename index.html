<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Denchfield Half-It Challenge!</title>
<style>
  /* General page styles */
  body {
    font-family: Arial, sans-serif;
    padding: 20px;
    max-width: 800px;
    margin: auto;
    background: #fff;
    color: #222;
    transition: background 0.3s, color 0.3s;
  }
  body.dark {
    background: #121212;
    color: #ddd;
  }
  input, button, select, textarea {
    font-size: 1em;
    padding: 8px;
    margin: 5px 0;
    width: 100%;
    box-sizing: border-box;
    border-radius: 4px;
    border: 1px solid #ccc;
    transition: background-color 0.3s, color 0.3s, border-color 0.3s;
  }
  body.dark input, body.dark textarea {
    background: #333;
    color: #eee;
    border-color: #555;
  }
  button {
    cursor: pointer;
    border: none;
    background-color: #0044cc;
    color: white;
    font-weight: bold;
    transition: background-color 0.3s ease;
  }
  button:hover {
    background-color: #003399;
  }
  button:disabled {
    background-color: #888;
    cursor: not-allowed;
  }
  #commandList, #gameArea, #historyArea, #playerButtons {
    margin-top: 20px;
  }
  .hidden {
    display: none !important;
  }
  .commandBox {
    font-size: 2em;
    margin: 15px 0;
    padding: 10px;
    background: #f0f0f0;
    border-radius: 5px;
    font-weight: bold;
    user-select: none;
  }
  body.dark .commandBox {
    background: #222;
  }
  .commandBox.current {
    font-size: 2.4em;
    font-weight: bolder;
    text-align: center;
    padding: 20px;
    border: 2px solid #0044cc;
    border-radius: 8px;
    background: #d0e0ff;
    color: #003366;
  }
  body.dark .commandBox.current {
    background: #0055ff;
    color: white;
    border-color: #3399ff;
  }
  .commandBox.hardcore {
    color: red;
    font-weight: bolder;
    text-shadow: 0 0 5px red;
  }
  .descriptionBox {
    font-size: 0.9em;
    margin: 10px 0;
    font-style: italic;
    min-height: 1.2em;
    user-select: none;
  }
  .score {
    font-size: 1.4em;
    margin: 10px 0;
  }
  #scoreboard {
    background: #eef;
    padding: 10px;
    margin-top: 10px;
    border-radius: 5px;
    user-select: none;
  }
  body.dark #scoreboard {
    background: #223344;
  }
  #scoreboard ul {
    padding-left: 20px;
    margin: 0;
  }
  .player-btn {
    margin: 5px 5px 5px 0;
    padding: 5px 10px;
    cursor: pointer;
    background-color: #ccc;
    border: none;
    border-radius: 4px;
    transition: 0.3s ease;
    user-select: none;
    position: relative;
    display: inline-flex;
    align-items: center;
  }
  .player-btn.selected {
    background-color: #0044cc;
    color: white;
    font-weight: bold;
    box-shadow: 0 0 5px #0044cc;
  }
  body.dark .player-btn {
    background-color: #444;
    color: #ddd;
  }
  body.dark .player-btn.selected {
    background-color: #3399ff;
    box-shadow: 0 0 8px #66aaff;
  }
  .player-btn .edit-player, .player-btn .delete-player {
    margin-left: 6px;
    font-size: 0.75em;
    background: transparent;
    border: none;
    cursor: pointer;
    color: inherit;
    font-weight: normal;
    padding: 2px 4px;
    border-radius: 3px;
    user-select: none;
    transition: background-color 0.2s;
  }
  .player-btn .edit-player:hover {
    background-color: #f99;
    color: #700;
  }
  .player-btn .delete-player:hover {
    background-color: #fcc;
    color: #900;
  }
  #toggleCommandList {
    margin-top: 10px;
    cursor: pointer;
    background: #ddd;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    user-select: none;
    width: auto;
  }
  body.dark #toggleCommandList {
    background: #444;
    color: #ddd;
  }
  label {
    user-select: none;
  }
  #playersSection, #roundsSection, #startScoreSection, #challengesSection {
    margin-bottom: 20px;
  }
  #gameControls button {
    width: 48%;
    margin: 5px 1% 5px 0;
  }
  #gameControls button:last-child {
    margin-right: 0;
  }
  /* Responsive small fixes */
  @media (max-width: 500px) {
    #gameControls button {
      width: 100%;
      margin: 5px 0;
    }
  }
</style>

<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

</head>
<body>

<!-- Dark mode toggle button -->
<button id="darkModeToggle" style="float:right; margin-top:-10px;">Toggle Dark Mode</button>

<h1>Denchfield Half-It Challenge!</h1>

<!-- Players Section -->
<section id="playersSection">
  <h2>Players</h2>
  <input id="newPlayerName" placeholder="Add new player name" aria-label="New player name" />
  <button onclick="addPlayer()">Add Player</button>
  <div id="playerButtons" aria-label="Player selection buttons"></div>
</section>

<!-- Rounds and starting score inputs -->
<section id="roundsSection">
  <h2>Game Settings</h2>
  <label for="numRounds">Number of rounds:</label>
  <input type="number" id="numRounds" min="1" max="100" value="10" aria-label="Number of rounds" />
  <label for="startingScore">Starting score (default 0):</label>
  <input type="number" id="startingScore" value="0" aria-label="Starting score" />
</section>

<!-- Challenges Section with toggle button -->
<section id="challengesSection">
  <button id="toggleCommandList">Toggle Challenge List</button>
  <div id="commandList" aria-label="List of challenges"></div>

  <!-- Inputs to add new challenge -->
  <input id="newCommandText" placeholder="New challenge text" aria-label="New challenge text" />
  <input id="newCommandDesc" placeholder="Optional description" aria-label="New challenge description" />
  <button onclick="addCommand()">Add Challenge</button>
</section>

<!-- Game area visible during active game -->
<section id="gameArea" class="hidden" aria-live="polite" aria-atomic="true">
  <h2>Current Turn</h2>

  <!-- Current challenge display with hardcore toggle if applicable -->
  <div id="currentChallenge" class="commandBox"></div>
  <div class="descriptionBox" id="challengeDescription"></div>

  <div id="hardcoreToggleContainer" class="hidden" style="margin:10px 0;">
    <label>
      <input type="checkbox" id="hardcoreToggle" />
      Hardcore Challenge (Failing resets score to 0)
    </label>
  </div>

  <!-- Score input and submit/fail buttons -->
  <div id="gameControls">
    <input type="number" id="scoreInput" placeholder="Enter score for this challenge" min="0" aria-label="Score input" />
    <button onclick="submitScore()">Submit Score</button>
    <button onclick="failChallenge()">Fail</button>
    <button onclick="undoScore()" title="Undo last score">Undo</button>
  </div>
</section>

<!-- Scoreboard showing players' scores -->
<section id="scoreboard" aria-live="polite" aria-atomic="true">
  <h2>Scoreboard</h2>
  <ul id="scoreList"></ul>
</section>

<script>
  /* 
    Firebase setup - replace these config values with your own Firebase project config 
    This example uses Firestore for persistent state sharing.
  */
  const firebaseConfig = {
    apiKey: "AIzaSyAusKA2YiJTelSm54EJfRbVJMk0M6mh_WM",
    authDomain: "denchfield-half-it.firebaseapp.com",
    projectId: "denchfield-half-it",
    storageBucket: "denchfield-half-it.firebasestorage.app",
    messagingSenderId: "494344468882",
    appId: "1:494344468882:web:7a1f0d2ac938627206e94b",
    measurementId: "G-ZQQM5PNWPV"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // =======================
  // Game state variables
  // =======================
  let players = []; // {id, name}
  let selectedPlayerId = null;
  let commands = []; // {id, text, description}
  let hardcoreIndices = []; // Indices of challenges that have hardcore toggle
  let rounds = 10;
  let startingScore = 0;

  // Current game progress
  let currentRound = 0; // round number 0-based
  let currentPlayerIndex = 0;
  let scores = {}; // playerId => current score
  let history = []; // Array of {playerId, round, commandIndex, score, hardcore, success}

  // UI elements for easy access
  const playerButtonsDiv = document.getElementById("playerButtons");
  const commandListDiv = document.getElementById("commandList");
  const currentChallengeDiv = document.getElementById("currentChallenge");
  const challengeDescriptionDiv = document.getElementById("challengeDescription");
  const scoreInput = document.getElementById("scoreInput");
  const scoreListUl = document.getElementById("scoreList");
  const hardcoreToggleContainer = document.getElementById("hardcoreToggleContainer");
  const hardcoreToggle = document.getElementById("hardcoreToggle");
  const gameArea = document.getElementById("gameArea");
  const toggleCommandListBtn = document.getElementById("toggleCommandList");
  const numRoundsInput = document.getElementById("numRounds");
  const startingScoreInput = document.getElementById("startingScore");
  const newPlayerNameInput = document.getElementById("newPlayerName");
  const newCommandTextInput = document.getElementById("newCommandText");
  const newCommandDescInput = document.getElementById("newCommandDesc");
  const darkModeToggleBtn = document.getElementById("darkModeToggle");

  // Utility to generate unique IDs for players/commands
  function generateId() {
    return '_' + Math.random().toString(36).substr(2, 9);
  }

  // ===========================
  // Initialize from Firestore or defaults
  // ===========================
  async function loadState() {
    try {
      // Load players
      const playersSnap = await db.collection("players").get();
      players = playersSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

      // Load commands
      const commandsSnap = await db.collection("commands").get();
      commands = commandsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

      // Load settings (rounds & starting score)
      const settingsDoc = await db.collection("settings").doc("gameSettings").get();
      if(settingsDoc.exists){
        const data = settingsDoc.data();
        rounds = data.rounds ?? 10;
        startingScore = data.startingScore ?? 0;
      }

      // Load progress/history
      const progressDoc = await db.collection("progress").doc("gameProgress").get();
      if(progressDoc.exists){
        const data = progressDoc.data();
        currentRound = data.currentRound ?? 0;
        currentPlayerIndex = data.currentPlayerIndex ?? 0;
        scores = data.scores ?? {};
        history = data.history ?? [];
      } else {
        // Init empty scores if none stored
        for(const p of players) scores[p.id] = startingScore;
      }

      // Update UI inputs
      numRoundsInput.value = rounds;
      startingScoreInput.value = startingScore;

      renderAll();
    } catch (err) {
      console.error("Error loading state:", err);
      alert("Failed to load game state from database. Starting fresh.");
      // Initialize defaults for new game
      players = [];
      commands = [];
      currentRound = 0;
      currentPlayerIndex = 0;
      scores = {};
      history = [];
      rounds = parseInt(numRoundsInput.value) || 10;
      startingScore = parseInt(startingScoreInput.value) || 0;
      renderAll();
    }
  }

  // ===========================
  // Save state to Firestore
  // ===========================
  async function saveState() {
    try {
      // Save players
      const batch = db.batch();
      // Clear all players and re-add to simplify sync:
      const playersCol = db.collection("players");
      const playersSnap = await playersCol.get();
      playersSnap.docs.forEach(doc => batch.delete(doc.ref));
      players.forEach(p => {
        batch.set(playersCol.doc(p.id), {name: p.name});
      });

      // Save commands similarly
      const commandsCol = db.collection("commands");
      const commandsSnap = await commandsCol.get();
      commandsSnap.docs.forEach(doc => batch.delete(doc.ref));
      commands.forEach(c => {
        batch.set(commandsCol.doc(c.id), {text: c.text, description: c.description});
      });

      // Save settings
      batch.set(db.collection("settings").doc("gameSettings"), {
        rounds,
        startingScore,
      });

      // Save progress
      batch.set(db.collection("progress").doc("gameProgress"), {
        currentRound,
        currentPlayerIndex,
        scores,
        history,
      });

      await batch.commit();
    } catch (err) {
      console.error("Error saving state:", err);
      alert("Failed to save game state to database.");
    }
  }

  // ===========================
  // Render functions
  // ===========================

  // Render player buttons with edit/delete and selection
  function renderPlayers() {
    playerButtonsDiv.innerHTML = "";
    players.forEach(p => {
      const btn = document.createElement("button");
      btn.textContent = p.name;
      btn.className = "player-btn";
      if(p.id === selectedPlayerId) btn.classList.add("selected");
      btn.setAttribute("aria-pressed", p.id === selectedPlayerId ? "true" : "false");
      btn.onclick = () => {
        if(selectedPlayerId === p.id){
          selectedPlayerId = null; // Deselect
        } else {
          selectedPlayerId = p.id;
        }
        renderPlayers();
        updateCurrentChallenge();
      };

      // Edit player button
      const editBtn = document.createElement("button");
      editBtn.textContent = "✎";
      editBtn.className = "edit-player";
      editBtn.title = "Edit player name";
      editBtn.onclick = (e) => {
        e.stopPropagation();
        const newName = prompt("Edit player name:", p.name);
        if(newName && newName.trim() !== ""){
          p.name = newName.trim();
          saveState().then(renderAll);
        }
      };
      btn.appendChild(editBtn);

      // Delete player button
      const delBtn = document.createElement("button");
      delBtn.textContent = "✕";
      delBtn.className = "delete-player";
      delBtn.title = "Delete player";
      delBtn.onclick = (e) => {
        e.stopPropagation();
        if(confirm(`Are you sure you want to delete player "${p.name}"? This cannot be undone.`)){
          players = players.filter(pl => pl.id !== p.id);
          // Remove player from scores and history
          delete scores[p.id];
          history = history.filter(h => h.playerId !== p.id);
          if(selectedPlayerId === p.id) selectedPlayerId = null;
          saveState().then(renderAll);
        }
      };
      btn.appendChild(delBtn);

      playerButtonsDiv.appendChild(btn);
    });
  }

  // Render the list of challenges with edit/delete
  function renderCommands() {
    commandListDiv.innerHTML = "";
    commands.forEach((c, i) => {
      const div = document.createElement("div");
      div.className = "commandBox";
      div.textContent = c.text + (c.description ? ` — ${c.description}` : "");
      div.title = `Challenge #${i + 1}`;
      div.style.fontSize = "1.2em";
      div.style.fontWeight = "normal";
      div.style.marginBottom = "8px";

      // Edit button
      const editBtn = document.createElement("button");
      editBtn.textContent = "✎";
      editBtn.style.marginLeft = "10px";
      editBtn.title = "Edit challenge";
      editBtn.onclick = () => {
        const newText = prompt("Edit challenge text:", c.text);
        if(newText && newText.trim() !== ""){
          c.text = newText.trim();
          const newDesc = prompt("Edit description (optional):", c.description || "");
          c.description = newDesc ? newDesc.trim() : "";
          saveState().then(renderAll);
        }
      };
      div.appendChild(editBtn);

      // Delete button
      const delBtn = document.createElement("button");
      delBtn.textContent = "✕";
      delBtn.style.marginLeft = "6px";
      delBtn.title = "Delete challenge";
      delBtn.onclick = () => {
        if(confirm(`Delete challenge #${i + 1}?`)){
          commands.splice(i, 1);
          saveState().then(renderAll);
        }
      };
      div.appendChild(delBtn);

      commandListDiv.appendChild(div);
    });
  }

  // Render the scoreboard showing current scores and highlight current player
  function renderScoreboard() {
    scoreListUl.innerHTML = "";
    players.forEach((p, i) => {
      const li = document.createElement("li");
      li.textContent = `${p.name}: ${scores[p.id] ?? startingScore}`;
      if(i === currentPlayerIndex && currentRound < rounds) {
        li.style.fontWeight = "bold";
        li.style.color = "#0044cc";
      }
      scoreListUl.appendChild(li);
    });
  }

  // Update current challenge and hardcore toggle visibility
  function updateCurrentChallenge() {
    if(currentRound >= rounds || players.length === 0 || commands.length === 0){
      // Game over or not enough data
      currentChallengeDiv.textContent = "Game over or setup incomplete.";
      challengeDescriptionDiv.textContent = "";
      hardcoreToggleContainer.classList.add("hidden");
      gameArea.classList.add("hidden");
      return;
    }

    gameArea.classList.remove("hidden");

    // Show current challenge text large and bold
    const challengeIndex = currentRound % commands.length;
    const cmd = commands[challengeIndex];
    currentChallengeDiv.textContent = cmd.text;
    challengeDescriptionDiv.textContent = cmd.description || "";

    // Add current class and hardcore style if applicable
    currentChallengeDiv.className = "commandBox current";
    if(isHardcoreChallenge(currentRound)){
      currentChallengeDiv.classList.add("hardcore");
      hardcoreToggleContainer.classList.remove("hidden");
    } else {
      hardcoreToggleContainer.classList.add("hidden");
      hardcoreToggle.checked = false;
    }

    scoreInput.value = "";
    scoreInput.focus();
  }

  // Determine if current challenge index is hardcore challenge
  function isHardcoreChallenge(roundIndex) {
    // Hardcore once every 10 challenges except last challenge (0-based rounds)
    if(commands.length === 0) return false;
    if(roundIndex === rounds - 1) return false; // Last challenge never hardcore
    return (roundIndex % 10 === 0);
  }

  // Render all UI parts
  function renderAll() {
    renderPlayers();
    renderCommands();
    renderScoreboard();
    updateCurrentChallenge();
  }

  // ===========================
  // Game logic functions
  // ===========================

  // Add player from input
  function addPlayer() {
    const name = newPlayerNameInput.value.trim();
    if(!name){
      alert("Player name cannot be empty");
      return;
    }
    const existing = players.find(p => p.name.toLowerCase() === name.toLowerCase());
    if(existing){
      alert("Player with this name already exists");
      return;
    }
    const id = generateId();
    players.push({id, name});
    scores[id] = startingScore;
    selectedPlayerId = id; // Select new player automatically
    newPlayerNameInput.value = "";
    saveState().then(renderAll);
  }

  // Add challenge from inputs
  function addCommand() {
    const text = newCommandTextInput.value.trim();
    if(!text){
      alert("Challenge text cannot be empty");
      return;
    }
    const description = newCommandDescInput.value.trim();
    const id = generateId();
    commands.push({id, text, description});
    newCommandTextInput.value = "";
    newCommandDescInput.value = "";
    saveState().then(renderAll);
  }

  // Submit a score for current player and advance game
  function submitScore() {
    if(!selectedPlayerId){
      alert("Select a player first");
      return;
    }
    const val = scoreInput.value.trim();
    if(val === ""){
      alert("Enter a score");
      return;
    }
    const scoreVal = parseInt(val);
    if(isNaN(scoreVal) || scoreVal < 0){
      alert("Score must be a positive number");
      return;
    }

    const hardcore = hardcoreToggle.checked;

    // Update player score according to hardcore toggle
    if(hardcore && scoreVal === 0){
      // Fail case: reset score to 0
      scores[selectedPlayerId] = 0;
    } else {
      scores[selectedPlayerId] = (scores[selectedPlayerId] || startingScore) + scoreVal;
    }

    // Save this attempt in history
    history.push({
      playerId: selectedPlayerId,
      round: currentRound,
      commandIndex: currentRound % commands.length,
      score: scoreVal,
      hardcore,
      success: true
    });

    advanceTurn();
  }

  // Mark challenge as failed by current player (score 0 or reset if hardcore)
  function failChallenge() {
    if(!selectedPlayerId){
      alert("Select a player first");
      return;
    }
    const hardcore = hardcoreToggle.checked;

    if(hardcore){
      scores[selectedPlayerId] = 0;
    }

    history.push({
      playerId: selectedPlayerId,
      round: currentRound,
      commandIndex: currentRound % commands.length,
      score: 0,
      hardcore,
      success: false
    });

    advanceTurn();
  }

  // Advance to next round/player
  function advanceTurn() {
    currentRound++;
    if(currentRound >= rounds){
      alert("Game finished!");
      gameArea.classList.add("hidden");
      saveState();
      renderScoreboard();
      return;
    }
    currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
    selectedPlayerId = players[currentPlayerIndex]?.id || null;

    saveState().then(() => {
      renderAll();
    });
  }

  // Undo last score
  function undoScore() {
    if(history.length === 0){
      alert("No actions to undo");
      return;
    }
    const last = history.pop();
    // Recalculate scores from scratch using history
    scores = {};
    players.forEach(p => scores[p.id] = startingScore);
    for(let h of history){
      if(h.success){
        if(h.hardcore && h.score === 0){
          scores[h.playerId] = 0;
        } else {
          scores[h.playerId] = (scores[h.playerId] || startingScore) + h.score;
        }
      }
    }

    currentRound = last.round;
    currentPlayerIndex = players.findIndex(p => p.id === last.playerId);
    selectedPlayerId = last.playerId;

    saveState().then(() => {
      renderAll();
    });
  }

  // Toggle challenge list visibility
  toggleCommandListBtn.onclick = () => {
    if(commandListDiv.classList.contains("hidden")){
      commandListDiv.classList.remove("hidden");
      toggleCommandListBtn.textContent = "Hide Challenge List";
    } else {
      commandListDiv.classList.add("hidden");
      toggleCommandListBtn.textContent = "Show Challenge List";
    }
  };

  // Update rounds and starting score on input change and reset game
  numRoundsInput.onchange = () => {
    rounds = Math.max(1, parseInt(numRoundsInput.value) || 10);
    resetGame();
  };
  startingScoreInput.onchange = () => {
    startingScore = parseInt(startingScoreInput.value) || 0;
    // Reset scores for all players
    players.forEach(p => scores[p.id] = startingScore);
    saveState().then(renderAll);
  };

  // Reset game progress but keep players and commands
  function resetGame() {
    currentRound = 0;
    currentPlayerIndex = 0;
    history = [];
    // Reset scores to startingScore
    players.forEach(p => scores[p.id] = startingScore);
    selectedPlayerId = players.length > 0 ? players[0].id : null;
    saveState().then(renderAll);
  }

  // Dark mode toggle with persistence in localStorage
  function loadDarkMode() {
    if(localStorage.getItem("darkMode") === "true"){
      document.body.classList.add("dark");
    }
  }
  darkModeToggleBtn.onclick = () => {
    document.body.classList.toggle("dark");
    localStorage.setItem("darkMode", document.body.classList.contains("dark"));
  };

  // Initialize app
  loadDarkMode();
  loadState();

</script>

</body>
</html>
